#include <vector>
#include <string>

#include "absl/strings/str_join.h"
#include "absl/strings/str_split.h"
#include "psg/lib/picosha2.h"
#include "psg/lib/edfplus.h"

#include "psg/event/arousal.h"
#include "psg/event/spo2.h"
#include "psg/event/stage.h"
#include "psg/event/pose.h"
#include "psg/event/leg.h"
#include "psg/event/resp.h"
#include "psg/event/heart.h"


/*
#include "psg/report/stage.h"
#include "psg/report/leg.h"
#include "psg/report/heart.h"
#include "psg/report/spo2.h"
#include "psg/report/resp.h"
#include "psg/report/pose.h"
#include "psg/report/chart.h"
*/
#include "psg/api/api.h"

namespace psg {
  // api as core controller
    
  Api::Api() {
    // maybe add here
  }



  void Api::put(const std::vector<unsigned char>& data) {
    // hash data
    std::string hex_str = get_hash256(data);
    std::cout << hex_str << '\n';
    db[hex_str].status = "0";
    auto edf = new EdfPlus(data);

    std::cerr << "Start analysis stage event...\n";
    add_stage_event(db, hex_str, edf);

    std::cerr << "Start analysis heart event...\n";
    add_heart_event(db, hex_str, edf);

    std::cerr << "Start analysis arousal event...\n";
    add_arousal_event(db, hex_str, edf);
    
    std::cerr << "Start analysis spo2 event...\n";
    // spo2 depend on heart, stage
    add_spo2_event(db, hex_str, edf);

    std::cerr << "Start analysis leg event...\n" ;   
    add_leg_event(db, hex_str, edf);
        /*        
    std::cerr << "Start analysis resp event...\n";
    add_resp_event(db, hex_str, edf);

    std::cerr << "Start analysis pose event...\n";
    add_pose_event(db, hex_str, edf);
    delete edf;
    db[hex_str].status = "1";
    */
    // generate_report(hex_str);
  }

  void Api::generate_report(std::string hex_str) {
    // sleep_onset depended by others
    /*
    ucout << "Start generate stage report\n";
    report::Stage stage(db, hex_str);
    stage();
    ucout << "Start generate leg report\n";
    report::Leg leg(db, hex_str);
    leg();
    ucout << "Start generate heart report\n";
    report::Heart heart(db, hex_str);
    heart();
    ucout << "Start generate spo2 report\n";
    report::Spo2 spo2(db, hex_str);
    spo2();
    ucout << "Start generate resp report\n";
    report::Resp resp(db, hex_str);
    resp();
    ucout << "Start generate pose report\n";    
    report::Pose pose(db, hex_str);
    pose();
    ucout << "Start generate chart report\n";
    report::Chart chart(db, hex_str);
    chart();
    report_is_fresh_ = true;
    ucout << "Report Generated!\n";
    */
  }

  void write_key_val_to_json(web::json::value& db, std::string key, std::string val) {
    std::wstring key_str(key.begin(), key.end());
    std::wstring val_str(val.begin(), val.end());
    #ifdef _WIN32
    db[key_str] = web::json::value(val_str);
    #else
    db[key] = web::json::value::string(val);
    #endif
  }
  
  web::json::value Api::get(const std::string& key) {
    std::vector<std::string> paths = absl::StrSplit(key, '/');
    std::string hex_str = paths[0];

    web::json::value ret = web::json::value::object();
    if (db.find(hex_str) == db.end()) {
      return ret;
    }
	
    if (key == hex_str) {
      ret[key] = web::json::value::string(db[hex_str].status);
      return ret;
    }
    ucout << "start generate report if not generated!\n";
    if (!report_is_fresh_) generate_report(hex_str);
    ucout << "report generated!\n";
	std::string val = "";
    if (absl::StartsWith(key, hex_str + "/Events/Arousal/")) {
      auto events = db[hex_str].events.arousal;
      val = comm::to_string(events);
    } else if (absl::StartsWith(key, hex_str + "/Events/Leg/")) {
      auto events = db[hex_str].events.leg;
	  val = comm::to_string(events);
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_OA/")) {
      auto events = db[hex_str].events.resp_oa;
      val = comm::to_string(events);
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_CA/")) {
      auto events = db[hex_str].events.resp_ca;
      val = comm::to_string(events);
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_MA/")) {
      auto events = db[hex_str].events.resp_ma;
      val = comm::to_string(events);
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_Hypnea/")) {
      auto events = db[hex_str].events.resp_hyp;
      val = comm::to_string(events);
    } else if (absl::StartsWith(key, hex_str + "/Events/SpO2/")) {
      auto events = db[hex_str].events.spo2;
      val = comm::to_string(events);
    } else if (absl::StartsWith(key, hex_str + "/Events/Stage/")) {
      auto events = db[hex_str].events.stage;
      val = comm::to_string(events); 
    } else if (absl::StartsWith(key, hex_str + "/Report/Chart/")) {
      val = db[hex_str].chart.to_string();
    } else if (absl::StartsWith(key, hex_str + "/Report/")) {
      int key_st = hex_str.length() + 1;
      std::string report_key(key.begin()+key_st, key.end());
      val = db[hex_str].report[report_key];
    } else {
      // TODO return failure
    }
    write_key_val_to_json(ret, key, val);
    return ret;
  }

  void add_events(comm::Events& events, std::string val) {
    auto events_str = absl::StrSplit(val, '\n');
    for (auto evt : events_str) {
      std::vector<std::string> props = absl::StrSplit(evt, ',');
      int st = std::stoi(props[0]);
      int ed = std::stoi(props[1]);
      std::string signal_name = props[2];
      comm::Event event(st, ed, signal_name);
      events[event.to_string()] = event;
    }
  }
  
  void Api::post(const web::json::value& client) {
    report_is_fresh_ = false;
    auto client_obj = client.as_object();
    for (auto iter = client_obj.begin(); iter != client_obj.end(); iter++) {
      auto key_wstr = iter->first;
      auto val_wstr = iter->second.as_string(); // # "id,st,ed\n"
	  std::string key(key_wstr.begin(), key_wstr.end());
	  std::string val(val_wstr.begin(), val_wstr.end());
      std::vector<std::string> paths = absl::StrSplit(key, '/');
      std::string hex_str = paths[0];
      if (absl::StartsWith(key, hex_str + "/Events/Arousal/")) {
	add_events(db[hex_str].events.arousal, val);
      } else if (absl::StartsWith(key, hex_str + "/Events/Leg/")) {
	add_events(db[hex_str].events.leg, val);
      } else if (absl::StartsWith(key, hex_str + "/Events/Resp_OA/")) {
	add_events(db[hex_str].events.resp_oa, val);
      } else if (absl::StartsWith(key, hex_str + "/Events/Resp_CA/")) {
	add_events(db[hex_str].events.resp_ca, val);
      } else if (absl::StartsWith(key, hex_str + "/Events/Resp_MA/")) {
	add_events(db[hex_str].events.resp_ma, val);
      } else if (absl::StartsWith(key, hex_str + "/Events/Resp_Hypnea/")) {
	add_events(db[hex_str].events.resp_hyp, val);
      } else if (absl::StartsWith(key, hex_str + "/Events/SpO2/")) {
	add_events(db[hex_str].events.spo2, val);
      } else if (absl::StartsWith(key, hex_str + "/Events/Stage/")) {
	auto events_str = absl::StrSplit(val, '\n');
	for (auto evt : events_str) {
	  std::vector<std::string> props = absl::StrSplit(evt, ',');
	  int id = std::stoi(props[0]);
	  std::string label = props[1];
	  db[hex_str].events.stage[id] = label;
    	} 
      } else {
	// TODO unidentified key
      }
    }
    return;
  }
  
}









