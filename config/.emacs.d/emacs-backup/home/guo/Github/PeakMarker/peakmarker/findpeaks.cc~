#include <cmath>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <numeric>
#include <memory>
#include <cstdlib>
#include <boost/circular_buffer.hpp>

#include "findpeaks.h"

using std::vector;
using std::cout;
using std::string;

template <class T>
using buffer = boost::circular_buffer<T>;
using uint = unsigned int;

template <class T>
vector<int> np_diff(const T& ipks) {
  vector<int> rets(ipks.size()-1);
  for (uint i=0; i<ipks.size()-1; i++) {
    rets[i] = ipks[i+1] - ipks[i];
  }
  return rets;
}

template <class T>
vector<int> np_abs_diff(const T& ipks) {
  auto diffs = np_diff(ipks);
  vector<int> abs_diffs;
  abs_diffs.reserve(diffs.size());
  std::transform(diffs.begin(), diffs.end(), std::back_inserter(abs_diffs),
		 [](int diff) -> int { return std::abs(diff); } );
  return abs_diffs; 
}

vector<int> argsort(const vector<int>& vec) {
  vector<int> indexes = vector<int>(vec.size());
  std::iota(indexes.begin(), indexes.end(), 0);
  std::sort(indexes.begin(), indexes.end(),
	    [&vec](std::size_t i1, std::size_t i2)
	    {
	      return vec[i1] > vec[i2];
	    });
  return std::move(indexes);
}

vector<int> argsort(const vector<double>& vec) {
  vector<int> indexes = vector<int>(vec.size());
  std::iota(indexes.begin(), indexes.end(), 0);
  std::sort(indexes.begin(), indexes.end(),
	    [&vec](std::size_t i1, std::size_t i2)
	    {
	      return vec[i1] > vec[i2];
	    });
  return std::move(indexes);
}

template <class T>
vector<int> get_highest_peaks(const T& signal, const vector<int>& ipks) {
  int num_peaks = ipks.size();
  vector<double> peak_values = vector<double>(num_peaks);
  for (int i=0; i < num_peaks; i++) {
    peak_values[i] = signal[ipks[i]];
  }
  auto indexes = argsort(peak_values);
  vector<int> highest = vector<int>(num_peaks);
  for (int i=0; i < num_peaks; i++) {
    highest[i] = ipks[indexes[i]];
  }
  return std::move(highest);
}

template <class T>
vector<int> findpeaks(const T& signal, float threshold, int min_dist) {
  int len = signal.size();
  double signal_max = *std::max_element(signal.begin(), signal.end());
  double signal_min = *std::min_element(signal.begin(), signal.end());
  float thres = threshold * (signal_max - signal_min) + signal_min;
  vector<double> diffs(len-1);
  for (int i = 0; i<len-1; i++) {
    diffs[i] = signal[i+1] - signal[i];
  }
  vector<int> ipks;
  for (uint i = 0; i < diffs.size(); i++) {
    if (diffs[i]   >= 0 &&
	diffs[i+1] <= 0 &&
	signal[i] > thres) {
      ipks.push_back(i+1);
    }
  }
  if (ipks.size() <= 1 || min_dist <= 1) {
    return std::move(ipks);
  }

  auto highest_ipks = get_highest_peaks<T>(signal, ipks);
  auto flags = vector<bool>(signal.size(), false);
  for (const auto idx: ipks)
    flags[idx] = true;

  for (const auto ipk: highest_ipks) {
    if (flags[ipk]) {
      auto sl_st = std::max(0, ipk - min_dist);
      auto sl_ed = std::min(int(signal.size()-1), ipk + min_dist);
      for (int i=sl_st; i<=sl_ed; i++)
	flags[i] = false;
      flags[ipk] = true;
    }
  }  
  vector<int> ipks_selected;
  ipks_selected.reserve(128);
  for (uint i=0; i < flags.size(); i++) {
    if (flags[i]) {
      ipks_selected.push_back(i);
    }
  }
  return std::move(ipks_selected);
}

int argmax(const vector<int>& hist) {
  int max_value = 0;
  int max_index = -1;
  for (uint i=0; i < hist.size(); i++) {
    if (hist[i] > max_value) {
      max_value = hist[i];
      max_index = i;
    }
  }
  return max_index;
}

int get_median(vector<int> vec) {
  int vec_size = vec.size();
  assert(vec_size>=1);
  if (vec_size == 1)
    return vec[0];
  std::sort(vec.begin(), vec.end());  
  auto div_ret = div(vec_size, 2);
  if (div_ret.rem == 0)
    return vec[vec_size/2];
  auto v1 = vec[vec_size/2];
  auto v2 = vec[vec_size/2-1];
  //  std::cout << v1 << ',' << v2 << ',' << vec_size/2 << std::endl;
  return (v1+v2)/ 2.0;
}

int get_most_common(const vector<int>& cycles, int num_bins=10) {
  assert(cycles.size() >= 1);
  if (cycles.size() == 1) {
    return cycles[0];
  }
  if (cycles.size() <= 5) {
    int m = 0;
    for (auto c: cycles) {
      m += c;
    }
    return m / cycles.size();
  }
  
  int min = *std::min_element(cycles.begin(), cycles.end());
  int max = *std::max_element(cycles.begin(), cycles.end());
  float bin_len = (max - min+1) / float(num_bins-1);

  vector<int> histarr(num_bins, 0); // index -- count
  for (const auto cycle : cycles) {
    int bin_id = (cycle - min) / bin_len;
    histarr[bin_id] += 1;
  }
  int max_bin_id = argmax(histarr);

  vector<int> selected_cycles;
  float bin_lower = min + bin_len * max_bin_id;
  float bin_upper = min + bin_len * (max_bin_id + 1);
  for (auto cycle: cycles) {
    if (cycle >= bin_lower && cycle < bin_upper)
      selected_cycles.push_back(cycle);
  }
  //  print_vector(selected_cycles, "selected_cycles");
  int avg_cycle = get_median(selected_cycles);
  //  std::cout << "avg_cycle:" << avg_cycle << std::endl;
  return avg_cycle;
}


PeakDetector::PeakDetector(int Fz,
			   int buffer_size,
			   int update_interval,
			   float threshold,
			   int min_dist,
			   int num_peaks) {
  this->__Fz_              = Fz;
  this->__buffer_size_     = buffer_size;
  this->__signal_          = buffer<double>(buffer_size);
  this->__recent_ipks_     = buffer<int>(num_peaks);
  this->__min_dist_        = min_dist;
  this->__threshold_       = threshold;
  this->__update_interval_ = update_interval;
  this->__update_clock_    = update_interval;
  this->__current_peak_rate_ = 0;
  this->__next_value_index_  = 0;
  this->__ipk_delay_ = 30;
}

int PeakDetector::run(double value) {
  this->__signal_.push_back(value);
  this->__next_value_index_ += 1;
  this->__update_clock_ -= 1;
  if (this->__update_clock_ == 0) {
    this->__real_run();
    this->__update_peak_rate();
    this->__update_clock_ = this->__update_interval_;
  }
  return this->__current_peak_rate_;
}


void PeakDetector::__real_run() {
  if (!this->__signal_.full()) {
    return;
  }
  vector<int> ipks   = findpeaks<buffer<double>>(this->__signal_,
					      this->__threshold_,
					      this->__min_dist_);
  auto signal_length = this->__signal_.size();
  int ipk_max        = signal_length - this->__ipk_delay_;
  int ipk_min        = ipk_max       - this->__update_interval_;
  int index_offset = this->__next_value_index_ - signal_length;

  if (this->__recent_ipks_.size() == 0) {
    for (auto ipk : ipks) {
      if (ipk <= ipk_max)
	this->__recent_ipks_.push_back(ipk);
    }
    return;
  }
  for (auto begin = ipks.cbegin(); begin != ipks.cend(); begin++) {
    if (*begin <= ipk_min || *begin > ipk_max) {
      continue;
    }
    this->__recent_ipks_.push_back(*begin + index_offset);
  }
}

void PeakDetector::__update_peak_rate() {
  auto num_ipks = this->__recent_ipks_.size();
  if (num_ipks < 2) {
    return;
  }
  vector<int> cycles = np_abs_diff<buffer<int>>(this->__recent_ipks_);
  auto avg_cycle = get_most_common(cycles);
  this->__current_peak_rate_ = round(60.0 * this->__Fz_ / avg_cycle);
}


/*
int main() {
  using std::cout;
  using std::string;

  std::ifstream in("/home/guo/AwareCore/RespiriatoryRate/physio2/data/");
  if (!in.is_open()) {
    cout << "file not opened!\n";
    exit(0);
  }
  string line;
  int signal_length = 1000*60;
  vector<int> signal;
  signal.reserve(signal_length);
  int i = 0;
  while (getline(in, line)) {
    int val = std::stoi(line);
    signal.push_back(val);
    i += 1;
    if (i == signal_length) {
      break;
    }
  }
  
  in.close();

  int Fz = 75;
  int buffer_size = Fz*25;
  int update_interval = Fz*1;
  float threshold = 0.75;
  int min_dist = 60;
  int num_peaks = 3;
  auto detector = PeakDetector(Fz, buffer_size, update_interval, threshold, min_dist, num_peaks);

  int ii = 0;
  int last_rate =  0;
  for (const auto value: signal) {
    auto rate = detector.run(value);
    ii += 1;
    if (ii < buffer_size)
      continue;
    if (rate != last_rate) {
      cout << rate <<'\n';
      last_rate = rate;
    }
  }
  cout << '\n';

  vector<int> ipks = findpeaks<vector<int>>(signal, 0.75, 1500);
  cout << "ipks size: " << ipks.size() << '\n';
  for (auto idx: ipks) {
    cout << idx << ',';
  }
  cout << '\n';

  return 0;
}


*/
