
#include <iostream>

#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/framework/op.h"
#include "tensorflow/core/graph/graph.h"
#include "tensorflow/core/graph/node_builder.h"
#include "tensorflow/core/graph/graph_def_builder.h"
#include "tensorflow/core/lib/core/status.h"
#include "tensorflow/core/lib/core/stringpiece.h"
#include "tensorflow/core/lib/gtl/array_slice.h"

using namespace tensorflow;

/*
namespace ops {
  Node* MyOps(NodeBuilder::NodeOut input, const GraphDefBuilder::Options& opts) {
    if (opts.HaveError()) return nullptr;
    static const string kOpName = "MyOps";
    NodeBuilder node_builder(opts.GetNameForOp(kOpName), kOpName,
			     opts.op_registry());
    node_builder.Input(input);
    return opts.FinalizeBuilder(&node_builder);
  }
}

using namespace tensorflow::ops;
*/
/*
void build_graph() {
  GraphDefBuilder b;
  using namespace ::tensorflow::ops;
  Node* na = Const(7, b.opts());
  Node* nb = Const(5, b.opts().WithName("control-input"));
  Node* nc = MyOps(na, b.opts().WithControlInput(nb));
  GraphDef graph_def;
  Status status = b.ToGraphDef(&graph_def);
  if (!status.ok()) {}
  return;
}
*/

int main() {
  //  build_graph();
  //OpRegistry *registry = new OpRegistry;
  
  
  
  return 0;
}

/*  
  tensorflow::SessionOptions options;
  std::unique_ptr<tensorflow::Session>
    session(tensorflow::NewSession(options));

  tensorflow::Status s = session->Create(graph);
  if (!s.ok()) {...}
  
  std::vector<tensorflow::Tensor> outputs;
  s = session->Run({}, {"output:0"}, {"update_state"}, &outputs);
  if (!s.ok()) {}

  auto output_tensor = outputs[0].flat<float>();

  session->Close();
*/
