""" ISRUC dataset """

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import os
import pdb
import glob
import time
import random
import pickle
import shutil
import numpy as np
import matplotlib.pyplot as plt
from ecg.ecgpeaks import findpeaks_in_ecg
from scipy.io import loadmat
from scipy.signal import medfilt

from plotly.offline import plot
import plotly.graph_objs as go

np.random.seed(2019)


def find_intervals(example):
    example = example.tolist()
    peak_indices, peak_values = findpeaks_in_ecg(example,fs=200)
    intervals =  np.diff(peak_indices)
    intervals = list(map(lambda x : x*5, intervals))
    return intervals

def spike_filter(intervals):
    intervals = np.asarray(intervals)
    intervals_movmean = medfilt(intervals, 7)
    intervals_diff = intervals - intervals_movmean
    intervals_diff_sorted = np.copy(np.abs(intervals_diff))
    intervals_diff_sorted.sort()
    num_intervals = len(intervals)
    mean_diff = intervals_diff_sorted[int(num_intervals*0.90)]
    #pdb.set_trace()
    #plot([go.Scatter(y=intervals_diff[:300], mode="lines+markers")])
    for ind in range(num_intervals):
        cur_diff = np.abs(intervals_diff[ind])
        if cur_diff >= 2 * mean_diff:
            intervals_diff[ind] = 0
    intervals_filter = intervals_movmean + intervals_diff
    #plot(go.Figure([go.Scatter(y=intervals[:300], mode="lines+markers", name="raw intervals"),
                    #go.Scatter(y=intervals_filter[:300], mode="lines+markers", name="filtered intervals"),
                    #go.Scatter(y=intervals_movmean[:300], mode="lines", name="move mean")],
                   #layout=go.Layout(yaxis=dict(range=[600,780]))))
    return intervals_filter

def _mat2labelpath(matpath):
    subject_id = os.path.basename(matpath)[7:-4]
    dirname = os.path.dirname(matpath)
    dirname = dirname.replace("Extractedchannels", "")
    dirname = dirname.replace("ExtractedChannels", "")
    dirname = dirname.replace("-", "")
    # ...subgroup1/1/1_1.txt
    labelpath = dirname + "/" + str(subject_id) + "/" + str(subject_id) + "_1.txt"
    if "subgroupII" in dirname:
        session_id = os.path.basename(matpath)[7:-12]
        dirname = "/home/guo/physio/database/isruc/subgroupII/"
        labelpath = dirname + "/" + str(subject_id) + "/" + str(session_id) + '/' + str(subject_id) + "_1.txt"
    return labelpath


class IsrucDataset(object):

    def __init__(self, is_train=True,
                 channel_names=[], step_len=1,
                 class_balanced=True, is_heart=True):
        self.is_train = is_train
        self.channel_names = channel_names
        self.step_len = step_len
        self.class_balanced = class_balanced
        self.is_heart = is_heart
        isruc_dir = "/home/guo/physio/database/isruc/ExtractedChannels/"
        self.mat_files = glob.glob(isruc_dir + "*/**.mat", recursive=True)

    def _load_labels(self, matpath):
        labelpath = _mat2labelpath(matpath)
        label = np.loadtxt(labelpath)
        return label

    def load_subject(self, file_path):
        """ return (num_epochs, 6000, num_channels) """
        channels = self.channel_names
        raw_dict = loadmat(file_path, variable_names=channels)
        data = np.stack([raw_dict[c] for c in channels], axis=2)
        labels = self._load_labels(file_path)
        for ind,label in enumerate(labels):
            if label == 5:
                labels[ind] = 4
        return (data,labels)

    '''
    def generate_dataset(self):
        mat_files = self.mat_files
        random.shuffle(mat_files)
        num_files = len(mat_files)
        num_train = int(num_files * 0.6)
        num_val = int(num_files * 0.2)
        num_test = int(num_files * 0.2)
        train_files = mat_files[:num_train]
        val_files = mat_files[num_train:num_train+num_val]
        test_files = mat_files[-num_test:]
        if self.mode == "train":
            self.mat_files = train_files
        elif self.mode == "validation":
            self.mat_files = val_files
        elif self.mode == "test":
            self.mat_files = test_files
        else:
            raise Exception("unexpected mode")
        random.shuffle(self.mat_files)
    '''

    def generate_dataset(self):
        mat_files = self.mat_files
        for mat in mat_files:
            data, _ = self.load_subject(subject_file)
        

    def preprocess_example(self, example):
        pass

    def __call__(self, step_size=256):
        for subject_file in self.mat_files:
            data, labels = self.load_subject(subject_file)
            x = data.flatten()
            intervals = find_intervals(x)
            intervals = spike_filter(intervals)
            num_intervals = len(intervals)
            num_example = int((num_intervals / step_size))
            #plot([go.Scatter(y=x[:200*60*5])])
            for ind in range(num_example):
                start = ind * step_size
                end = (ind + 1) * step_size
                example = np.asarray(intervals[start:end], dtype=np.float32)
                intervals_input = example[:-1]
                intervals_input = intervals_input.reshape(-1, 1)
                intervals_output = example[1:].reshape(-1,1)
                yield (intervals_input, intervals_output)
            #example = target + np.random.randint(-10,10, size=len(target))

if __name__ == '__main__':
    fs = 200
    isruc = IsrucDataset(channel_names=["X2"], step_len=fs*60*5,
                         class_balanced=False)
    for example, label in isruc():
        print(len(example))
        plot([go.Scatter(y=example, mode="lines+markers")])
        break







