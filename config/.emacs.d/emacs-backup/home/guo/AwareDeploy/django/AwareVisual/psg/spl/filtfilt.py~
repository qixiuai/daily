#!/home/guo/anaconda3/bin

import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import *
from numpy.linalg import lstsq
#import filter_zi
from . import filter_zi

import pdb

def filter(b, a, x, zi):
    b = filter_zi.FloatVector(b.tolist())
    a = filter_zi.FloatVector(a.tolist())
    x = x.reshape(x.shape[0])
    x = filter_zi.FloatVector(x.tolist())
    zi = filter_zi.FloatVector(zi.tolist())
    y = filter_zi.FloatVector(x.size())
    filter_zi.float_filter(y, b, a, x, zi)
    y = np.asarray([val for val in y])
    return y

def filter2(b, a, x, zi):
    b = filter_zi.FloatVector(b.tolist())
    a = filter_zi.FloatVector(a.tolist())
    x = x.reshape(x.shape[0])
    x = filter_zi.FloatVector(x.tolist())
    zi = filter_zi.FloatVector(zi.tolist())
    y = filter_zi.FloatVector(x.size())
    filter_zi.float_filter(y, b, a, x, zi)
    y = np.asarray([val for val in y])
    zi = np.asarray([val for val in zi])
    return (y,zi)

def sosgfilt(sos, g, x):
    Npts, Nchans = x.shape
    b,a,zi,nfact,L = getCoeffsAndInitialConditions(sos, g, Npts)
    if Nchans == 1:
        if Npts < 10000:
            y = ffOneChanCat(b, a, x, zi, nfact, L)
        else:
            y = ffOneChan(b, a, x, zi, nfact, L)
    return y


def getCoeffsAndInitialConditions(sos, g, Npts):
    L, ncols = sos.shape
    ng = np.size(g)
    
    assert ncols == 6 and (L>1 or sos[3] == 1 and ng <= 2)
    assert ng <= L + 1,  "length of g cannot great than L+1"
    
    if (ng == L + 1):
        sos[-1, :3] = g[-1] * sos[-1, :3]
        ng -= 1
    for ii in range(ng):
        sos[ii, :3] = g[ii]*sos[ii, :3]
    
    ord = filtord(sos)
    a = sos[:, 3:].T;
    b = sos[:, :3].T;
    nfact = max(1, 3*ord)
    assert Npts > nfact, "input data too short"
    
    zi = np.zeros((2, L))
    for ii in range(L):
        rhs = b[1:3, ii] - b[0,ii] * a[1:3, ii]
        np.eye(2) - np.hstack([-a[1:3, ii].reshape(2,1), np.stack([[1], [0]]) ]);
        x, resid, rank, s = lstsq(np.eye(2) - np.hstack([-a[1:3, ii].reshape(2,1), np.stack([[1], [0]]) ]), rhs);
        zi[:, ii] = x;        
    return b, a, zi, nfact, L

def filtord(sos):
    [b,a] = sos2tf(sos) # get transfer function
    if (len(b) != 0 and np.max(np.abs(b)) != 0):
        b = b / np.max(np.abs(b))
    if (len(a) != 0 and np.max(np.abs(a)) != 0):
        a = a / np.max(np.abs(a))
    if (len(b) != 0):
        b = b[:np.where(b!=0)[0][-1]+1]
    if (len(a) != 0):
        a = a[:np.where(a!=0)[0][-1]+1]
    n = max(len(b), len(a)) - 1;
    return n;

def ffOneChanCat(sos, g, y, zi, nfact, L):
    for ii in range(L):
        y = np.concatenate([ 2*y[0]-np.flip(y[1:nfact+1], 0), y, 2*y[-1]-np.flip(y[-1-nfact:-1],0) ])
        y = filter(sos[:, ii], g[:, ii], y, zi=zi[:, ii]*y[0])
        y = np.flip(y, 0) # reverse vector y
        y = filter(sos[:, ii], g[:, ii], y, zi=zi[:, ii]*y[0])
        assert(nfact > 0)
        y = np.flip(y[nfact:-nfact], 0)
    return y;

def ffOneChan(sos, a, xc, zi, nfact, L):
    for ii in range(L):
        xt = -np.flip(xc[1:nfact+1],0) + 2*xc[0]
        print(zi[:,ii]*xt[0])
        _, zo = filter2(sos[:, ii], a[:, ii], xt, zi[:, ii]*xt[0])
        yc2,zo = filter2(sos[:, ii], a[:, ii], xc, zo)
        xt = -np.flip(xc[-1-nfact:-1], 0) + 2*xc[-1]
        yc3 = filter(sos[:, ii], a[:, ii], xt, zo)
        _,zo = filter2(sos[:,ii], a[:, ii], np.flip(yc3, 0), zi[:,ii]*yc3[-1])
        yc5 = filter(sos[:, ii], a[:, ii], np.flip(yc2, 0), zo)
        xc = np.flip(yc5, 0)
    y = xc
    return y


if __name__ == '__main__':
    from scipy.io import loadmat
    x = loadmat("/home/guo/AwareCore/Data/x.mat")['x']
    sos = loadmat("/home/guo/AwareCore/Data/SOS.mat")['SOS']
    g   = loadmat("/home/guo/AwareCore/Data/G.mat")['G']
    y = sosgfilt(sos, g, x)
