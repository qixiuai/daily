
#include <algorithm>
#include <fstream>
#include <vector>
#include <cstring>

#include "spdlog/spdlog.h"
#include "absl/strings/str_join.h"

using namespace std;


template <class T>
std::vector<T> load_signal(std::string filepath, int size) {
  std::ifstream in(filepath);
  if (!in.is_open()) {
    spdlog::error("file {} not found!", filepath);
  }
  std::string line;
  std::vector<T> signal;
  int i = 0;
  while (getline(in, line)) {
    int value = std::stof(line);
    signal.push_back(static_cast<T>(value));
    if (i++ >= size) break;
  }
  return signal;
}

template <class T>
void save_vector(const std::string& filepath,
		 const std::vector<T>& signal) {
  std::ofstream out(filepath, std::ofstream::out);
  std::string contents = absl::StrJoin(signal, ",");
  if (!out.is_open()) {
    spdlog::error("file {} cann't be created!", filepath);
  }
  out << contents + '\n';
  //  spdlog::info("signal : {}", contents);
  out.close();
}

int remaind(int a, int b) {
  //  a can be negative numbers
  return  (a % b + b) % b;
}


int output_len(int len_h, int in_len, int up, int down) {
  int in_len_copy = in_len + (len_h + remaind(-len_h, up)) / up - 1;
  int nt = in_len_copy * up;
  int need = nt / down;
  if (remaind(nt, down) > 0)
      need += 1;
  return need;
}

std::vector<float> upfirdn(std::vector<float> h,
			   std::vector<float> x,
			   int up,
			   int down) {
  return x;
}


std::vector<float> upfirdn(const std::vector<float>& h,
			   const std::vector<float>& x,
			   int up,
			   int down) {
  int output_len = output_len(h.size(), up, down);
  auto out = std::vector<float>(output_len, 0);
  apply(x, h, out, up, down);
}


vector<float> resample_poly(const vector<float>& signal, int up, int down) {
  if (up == 1 && down == 1)
    return signal;
  g_   = __gcd(up, down);
  up   = up / g_;
  down = down / g_;
  n_out = signal.size() * up;
  n_out = n_out / down;
  n_pre_pad = down - remaind(half_len, down);
  n_post_pad = 0;
  n_pre_remove = (half_len + n_pre_pad) / down;
  while (output_len(len(h) + n_pre_pad + n_post_pad, signal.size(),
		     up, down) < n_out + n_pre_remove):
    n_post_pad += 1;
  //h = concatenate(h);
  int h_pad_len = n_pre_pad + h.size() + n_post_pad;
  std::vector<float> h_pad = std::vector<float>(h_pad_len, 0);
  memcpy(h_pad.data() + h_pred_pad, h.data(), h.size() * 4);
  n_pre_remove_end = n_pre_remove + n_out;
  y = upfirdn(h, x, up, down);
  return y;
}

int main() {
  spdlog::info("resample_poly starts");
  const string project_dir  = "/home/guo/PSG/";
  const string data_dir     = "/home/guo/PSG/data/stage/";
  const string c4_file_name = "c4_a1.txt"; // 500Hz
  const string eeg_filepath = data_dir + c4_file_name;
  int eeg_size = 60*500;
  vector<float> signal = load_signal<float>(eeg_filepath, eeg_size);
  // resample signal from 500Hz to 300Hz;
  vector<float> signal_re = resample_poly(signal, 3, 5);

  save_vector<float>("/tmp/signal.csv", signal);
  save_vector<float>("/tmp/signal_re.csv", signal_re);

  spdlog::info("resample_poly ends");
  return 0;
}
