#include <cmath>
#include <cassert>
#include <fstream>
#include <memory>
#include <string>
#include <vector>

void output();

namespace DisMax {

  template <class T>
  class FixedBuffer {
  private:
    bool isIndexReversed;
    int window_size;

    T getElementWithIndexReversed(int index);
    T getElementWithIndexNormal(int index);
    void copyToFixedBuffer(const std::shared_ptr<T> data, int len, \
			   int buffer_start);
    
  public:
    std::shared_ptr<T> buffer;
    int buffer_size;
    int length;

    FixedBuffer(int window_size);

    T at(int index); // at not check whether index is illegal
    T operator[](int index);
    void updateFixedBuffer(const T* data, int len);
  };

  /*
  class DisMax {
  private:
    FixedBuffer<int> signal;
    FixedBuffer<float> mean;
    FixedBuffer<float> dev;
    FixedBuffer<float> max;
    FixedBuffer<int> duration;
    FixedBuffer<int> heart_position;

  public:
    void meanSignal();
    void devSignal();
    void envelopByMax();
    void durationOfPeak();
    void identifyHeartPosition();
    void heartRate();
  };

  class Config {
  public:
    int Fs;
    int window_size;
    int segment_size;
    Config(int Fs) Fs{Fs}, \
      window_size{std::floor(0.5*Fs)}, \
      segment_size{std::floor(2*Fs)} {}
  };

  class SignalReader {
  private:
    std::shared_ptr<int> buffer;
    int  buffer_size;
    int  length;
  
  public:
    SignalReader(int buffer_size) {
      this->buffer = std::make_shared<int>(buffer_size);
      this->buffer_size = buffer_size;
      this->length = 0;
    }
  
    std::vector<int> outputSignal() {
      std::vector<int> vec(buffer, buffer+length);
      return std::move(vec);
    }

    void readNextSegment(int* signal_segment, int segment_size) {
      // Interface between C#/Java and C++  
    }
  
    bool readNextSegmentFromFile(std::ifstream file) {
      int sample;
      int num_sample = 0;
      while (sample << file) {
	num_sample += 1;
	buffer[num_sample] = sample;
      }
      if (num_sample == buffer_size) {
	this->length = buffer_size;
	return false;
      }
      this->length = num_sample;
      return true;
    }
  };
  */
} // end namespace DisMax
