
#include "server/server.h"

#include <functional>
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/str_split.h"
#include "burn/burn.h"
#include "burn/lib/sha256/sha256.h"

using namespace web;

DataFlowServer::DataFlowServer(utility::string_t url): m_listener(url) {
  m_listener.support(methods::GET,
		     std::bind(&DataFlowServer::handle_get, this, std::placeholders::_1));
  m_listener.support(methods::PUT,
		     std::bind(&DataFlowServer::handle_put, this, std::placeholders::_1));
  m_listener.support(methods::POST,
		     std::bind(&DataFlowServer::handle_post, this, std::placeholders::_1));
  m_listener.support(methods::DEL,
		     std::bind(&DataFlowServer::handle_delete, this, std::placeholders::_1));
}

DataFlowServer::~DataFlowServer() {
  // release resources
}

void DataFlowServer::handle_error(pplx::task<void>& t) {
  try {
    t.get();
  }
  catch(...) {
    fprintf(stderr, "from handle error\n");
  }
}

void write_key_val_to_json(json::value& ret, std::string key, std::string val) {
  std::wstring key_str(key.begin(), key.end());
  std::wstring val_str(val.begin(), val.end());
#ifdef _WIN32
  ret[key_str] = json::value(val_str);
#else
  ret[key] = json::value::string(val);
#endif  
}

std::string events_to_string(std::vector<burn::Event> events, std::string tag) {
  std::string ret;
  int num_events = events.size();
  for (int i = 0; i < num_events; i++) {
    auto event = events[i];
    ret.append(std::to_string(event.start) + ',');
    ret.append(std::to_string(event.end) + ',');
    ret.append(tag + '\n');
  }
  return ret;
}

void DataFlowServer::handle_get(http_request message) {
  auto path = http::uri::decode(message.relative_uri().path());
  std::string no_root_path(path.begin()+1, path.end());
  std::string key = no_root_path;
  std::vector<std::string> paths = absl::StrSplit(key, '/');
  std::string hex_str = paths[0];
  json::value ret = json::value::object();

  if (named_sessions_.find(hex_str) == named_sessions_.end()) {
    message.reply(status_codes::OK, ret);
    return;
  }
  auto session = named_sessions_[hex_str];
  if (!session) {
    // session is nullptr
    auto args = named_args_[hex_str];
    session = new burn::Session(args);
    named_sessions_[hex_str] = session;
    
    write_key_val_to_json(ret, "is_running", "true");
    message.reply(status_codes::OK, ret);
    
    session->Run();
    return;
  }
  
  if (!session->finished) {
    write_key_val_to_json(ret, "is_running", "true");
  } else {
    write_key_val_to_json(ret, "is_running", "false");
    std::string val = "";
    if (absl::StartsWith(key, hex_str + "/Events/Arousal/")) {
      val = events_to_string(session->result.arousal, "");
    } else if (absl::StartsWith(key, hex_str + "/Events/Leg/")) {
      val = events_to_string(session->result.plms, "");
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_OA/")) {
      val = events_to_string(session->result.oas, "");
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_CA/")) {
      val = events_to_string(session->result.cas, "");
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_MA/")) {
      val = events_to_string(session->result.mas, "");
    } else if (absl::StartsWith(key, hex_str + "/Events/Resp_Hypnea/")) {
      val = events_to_string(session->result.hyps, "");
    } else if (absl::StartsWith(key, hex_str + "/Events/SpO2/")) {
      val = events_to_string(session->result.desats, "");
    } else if (absl::StartsWith(key, hex_str + "/Events/Stage/")) {
      //val = events_to_string(session->result.stages); //
      val = absl::StrJoin(session->result.stages, ",");
      val += '\n';
    } else if (absl::StartsWith(key, hex_str + "/Report/Chart/")) {
      val = session->result.chart;
    } else if (absl::StartsWith(key, hex_str + "/Report/")) {
      int key_st = hex_str.length() + 1;
      std::string report_key(key.begin()+key_st, key.end());
      val = session->result.report[report_key];
    } else {
      // TODO return failure
    }
    write_key_val_to_json(ret, key, val);
  }
  
  message.reply(status_codes::OK, ret);
  return;
}


void DataFlowServer::handle_put(http_request message) {
  //ucout << message.to_string() << '\n';
  message.extract_vector().then([&](std::vector<unsigned char> data) {
      std::string hex_str = burn::lib::sha256(data);
      named_sessions_[hex_str] = nullptr;
      auto args = new burn::Session::Args;
      named_args_[hex_str] = args;
      args->edf = data;
      message.reply(status_codes::OK);
    });
  return;
}

void add_events(std::vector<burn::Event>& events, std::string val) {
  absl::string_view val_strip = absl::StripSuffix(val, "\n");
  auto events_str = absl::StrSplit(val_strip, '\n');
  for (auto evt : events_str) {
    std::vector<std::string> props = absl::StrSplit(evt, ',');
    int st = std::stoi(props[0]);
    int ed = std::stoi(props[1]);
    std::string signal_name = props[2];
    burn::Event event(st, ed);
    //auto key = event.to_string();
    events.push_back(event);
  }
}


void DataFlowServer::handle_post(http_request message) {
  ucout << message.to_string() << '\n';
  message.extract_json().then([&](json::value client) {
      auto client_obj = client.as_object();
      for (auto iter = client_obj.begin(); iter != client_obj.end(); iter++) {
	auto key_wstr = iter->first;
	auto val_wstr = iter->second.as_string(); // # "id,st,ed\n"
	std::string key(key_wstr.begin(), key_wstr.end());
	std::string val(val_wstr.begin(), val_wstr.end());
	std::vector<std::string> paths = absl::StrSplit(key, '/');
	std::string hex_str = paths[0];
	if (absl::StartsWith(key, hex_str + "/Events/Arousal/")) {
	  add_events(named_args_[hex_str]->arousal, val);
	} else if (absl::StartsWith(key, hex_str + "/Events/Leg/")) {
	  add_events(named_args_[hex_str]->plms, val);
	} else if (absl::StartsWith(key, hex_str + "/Events/Resp_OA/")) {
	  add_events(named_args_[hex_str]->oas, val);
	} else if (absl::StartsWith(key, hex_str + "/Events/Resp_CA/")) {
	  add_events(named_args_[hex_str]->cas, val);
	} else if (absl::StartsWith(key, hex_str + "/Events/Resp_MA/")) {
	  add_events(named_args_[hex_str]->mas, val);
	} else if (absl::StartsWith(key, hex_str + "/Events/Resp_Hypnea/")) {
	  add_events(named_args_[hex_str]->hyps, val);
	} else if (absl::StartsWith(key, hex_str + "/Events/SpO2/")) {
	  add_events(named_args_[hex_str]->desats, val);
	} else if (absl::StartsWith(key, hex_str + "/Events/Stage/")) {
	  // unlabeled epochs with value -1
	  auto val_strip = absl::StripSuffix(val, "\n");
	  std::vector<std::string> stages = absl::StrSplit(val_strip, ',');
	  int num_stage = stages.size();
	  for (int i = 0; i < num_stage; i++) {
	    auto stage_str = stages[i];
	    int stage = std::stoi(stage_str);
	    named_args_[hex_str]->stages.push_back(stage);
	  }
	} else if (absl::StartsWith(key, hex_str + "/Light/Open/")) {
	  named_args_[hex_str]->open_light_ms = std::stoi(val);
	} else if (absl::StartsWith(key, hex_str + "/Light/Close/")) {
	  named_args_[hex_str]->close_light_ms = std::stoi(val);
	}
	else {
	  // TODO unidentified key
	}
      }
      message.reply(status_codes::OK);
    });
  return;
}

void DataFlowServer::handle_delete(http_request message) {
  ucout << message.to_string() << '\n';
  message.reply(status_codes::OK, message.extract_json().get());
  return;
}

