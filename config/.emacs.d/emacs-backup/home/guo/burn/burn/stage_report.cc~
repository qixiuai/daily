
#include "burn/stage_report.h"

namespace burn {

  int GetsleepOnsetEpochID(const std::vector<int>& stages,
			   int close_light_epoch_id,
			   int thres) {
    int num_sleep_epochs = 0;
    int sleep_onset_epoch_id = 0;
    int num_stages = stages.size();
  
    for (int epoch_id = close_light_epoch_id;
	 epoch_id < num_stages;
	 epoch_id++) {
    
      int label = stages[epoch_id];
      if (label == 0) {
	num_sleep_epochs = 0;
	continue;
      }
    
      // label is sleep
      if (num_sleep_epochs == 0)
	sleep_onset_epoch_id = epoch_id;
    
      num_sleep_epochs += 1;
    
      if (num_sleep_epochs >= thres)
	break;
    }
    return sleep_onset_epoch_id;
  }


  float GetStageDurationInMinutes(const std::vector<int>& stages,
				  int sleep_onset_epoch_id,
				  int open_light_epoch_id,
				  int stage) {
    int num_epochs = 0;
    for(int epoch_id = sleep_onset_epoch_id;
	epoch_id < open_light_epoch_id;
	epoch_id++) {
    
      int label = stages[epoch_id];
      if (label == stage)
	num_epochs += 1;
    
    }
    return num_epochs * 0.5;
  }

  float GetStageLatencyInMinutes(const std::vector<int>& stages,
				 int close_light_epoch_id,
				 int stage) {
    int num_latency_epochs = 0;
    int num_epochs = stages.size();
    for(int epoch_id = close_light_epoch_id;
	epoch_id < num_epochs;
	epoch_id++){
    
      int label = stages[epoch_id];
      num_latency_epochs += 1;
      if (label == stage)
	break;
    }  
    return num_latency_epochs * 0.5;
  }

  float GetNumWake(const std::vector<int>& stages,
		   int sleep_onset_epoch_id,
		   int open_light_prev_epoch_id) {
    float counter = 0;
    //int num_epochs = stages.size();
    bool is_wake = false;
    for(int epoch_id = sleep_onset_epoch_id;
	epoch_id < open_light_prev_epoch_id;
	epoch_id++){
      int label = stages[epoch_id];
      if (label == 0 and !is_wake) {
	counter += 1;
	is_wake = true;
      } else {
	if (is_wake)
	  is_wake = false;
      }
    }      
    return counter;
  }
  
  void StageReport::Run() {
    auto& table = rets_->table;    
    auto stages = args_->stages;
    int close_light_next_epoch_id = args_->close_light_next_epoch_id;
    int open_light_prev_epoch_id = args_->open_light_prev_epoch_id;
    
    int num_epochs = stages.size();
    if (num_epochs <= 2) return;    

    // get sleep onset 
    int sleep_onset_epoch_id = GetsleepOnsetEpochID(stages, close_light_next_epoch_id, 3);
    rets_->sleep_onset_epoch_id = sleep_onset_epoch_id;
    
    //stage table
    float wktib = GetStageDurationInMinutes(stages, sleep_onset_epoch_id,
					    open_light_prev_epoch_id, 0);
    float n1 = GetStageDurationInMinutes(stages, sleep_onset_epoch_id,
					 open_light_prev_epoch_id, 1);
    float n2 = GetStageDurationInMinutes(stages, sleep_onset_epoch_id,
					 open_light_prev_epoch_id, 2);
    float n3 = GetStageDurationInMinutes(stages, sleep_onset_epoch_id,
					 open_light_prev_epoch_id, 3);
    float rem = GetStageDurationInMinutes(stages, sleep_onset_epoch_id,
					 open_light_prev_epoch_id, 4);
    float tib = wktib + n1 + n2 + n3 + rem;
    float tst = tib - wktib;
    table["WKTIB_LastingTime"] = wktib;
    table["N1_LastingTime"] = n1;
    table["N2_LastingTime"] = n2;
    table["N3_LastingTime"] = n3;
    table["REM_LastingTime"] = rem;
    table["TSTTIB_LastingTime"] = tst / tib;
    
    table["WKTIB_TimeInBedRatio"] =  wktib / tib;
    table["N1_TimeInBedRatio"] =  n1 / tib;
    table["N2_TimeInBedRatio"] = n2 / tib;
    table["N3_TimeInBedRatio"] = n3 / tib;
    table["REM_TimeInBedRatio"] = rem / tib;

    table["N1_TotalSleepRatio"] = n1 / tst;
    table["N2_TotalSleepRatio"] = n2 / tst;
    table["N3_TotalSleepRatio"] = n3 / tst;
    table["REM_TotalSleepRatio"] = rem / tst;

    float sleep_onset_time = sleep_onset_epoch_id * 0.5;
    float n1_from_close_light = \
      GetStageLatencyInMinutes(stages, close_light_next_epoch_id, 1);
    float n2_from_close_light =	\
      GetStageLatencyInMinutes(stages, close_light_next_epoch_id, 2);
    float n3_from_close_light = \
      GetStageLatencyInMinutes(stages, close_light_next_epoch_id, 3);
    float rem_from_close_light = \
      GetStageLatencyInMinutes(stages, close_light_next_epoch_id, 4);
    table["SleepOnset_FromCloseLight"] = sleep_onset_time;
    table["N1_FromCloseLight"] = n1_from_close_light;
    table["N2_FromCloseLight"] = n2_from_close_light;
    table["N3_FromCloseLight"] = n3_from_close_light;
    table["REM_FromCloseLight"] = rem_from_close_light;
    
    table["N1_FromSleep"] = n1_from_close_light - sleep_onset_time;
    table["N2_FromSleep"] = n2_from_close_light - sleep_onset_time;
    table["N3_FromSleep"] = n3_from_close_light - sleep_onset_time;
    table["REM_FromSleep"] = rem_from_close_light - sleep_onset_time;
    
    table["SPT"] = tib - sleep_onset_time;
    table["NumWakeInSleep"] = \
      GetNumWake(stages, sleep_onset_epoch_id, open_light_prev_epoch_id);
    table["DurWakeInSleep"] = wktib - sleep_onset_time;

    
    std::string chart_stage = "Stage,";
    for (auto stage : session_state_->stages) {
      chart_stage.append(std::to_string(stage) + ',');
    }
    chart_stage[chart_stage.size()-1] = '\n';
    rets_->chart_stage chart_stage;
  }



}

