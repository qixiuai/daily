
#include "burn/heart_report.h"

#include <algorithm>
#include <numeric>

namespace burn {

  struct TableIndex {
    float max_hr;
    float min_hr;
    float mean_hr;
    float mean_hr_sleep_nrem;
    TableIndex() = default;
    TableIndex(float max_hr, float min_hr,
	       float mean_hr, float mean_hr_sleep_nrem) {
      this->max_hr = max_hr;
      this->min_hr = min_hr;
      this->mean_hr = mean_hr;
      this->mean_hr_sleep_nrem = mean_hr_sleep_nrem;
    }
  };
  
  void extend_vector(std::vector<float>* dst, std::vector<float>* src) {
    int n = src->size();
    for (int i = 0; i < n; i++) {
      float val = (*src)[i];
      dst->push_back(val);
    }
  }
  
  
  void GetTableIndex(TableIndex* table_index,
		     HeartReport::StageHeartRates& stage_heart_rates,
		     int sleep_onset_epoch_id) {
    std::vector<float> hrs_sleep;
    std::vector<float> hrs_sleep_nrem;
    int num_epochs = stage_heart_rates.size();
    for (int i = sleep_onset_epoch_id; i < num_epochs; i++) {
      auto stage_heart_rate = stage_heart_rates[i];
      auto stage = stage_heart_rate.stage;
      if (stage == 0) continue;
      auto heart_rates = stage_heart_rate.heart_rates;
      if (stage == 4) {
	extend_vector(&hrs_sleep_nrem, &heart_rates);
      }
      extend_vector(&hrs_sleep, &heart_rates);
    }

    // max_hr, min_hr, mean_hr
    float max_hr = 0;
    float sum_hr = 0;
    float min_hr = 1000;
    int num_hrs_sleep = hrs_sleep.size();
    for (int i = 0; i < num_hrs_sleep; i++) {
      float hr = hrs_sleep[i];
      sum_hr += hr;
      if (hr > max_hr) max_hr = hr;
      if (hr < min_hr) min_hr = hr;
    }
    float mean_hr = sum_hr / num_hrs_sleep;

    // mean_hrs_sleep_nrem
    int num_hrs_sleep_nrem = hrs_sleep_nrem.size();
    float sum_hrs_sleep_nrem = \
      std::accumulate(hrs_sleep_nrem.begin(), hrs_sleep_nrem.end(), 0);
    float mean_hr_sleep_nrem = sum_hrs_sleep_nrem / num_hrs_sleep_nrem;

    table_index->max_hr = max_hr;
    table_index->min_hr = min_hr;
    table_index->mean_hr = mean_hr;
    table_index->mean_hr_sleep_nrem = mean_hr_sleep_nrem;
  }


  void GetHREpochs(HeartReport::HREpochs* hr_epochs,
		   HeartReport::StageHeartRates& stage_heart_rates) {
    int num_epochs = stage_heart_rates.size();
    for (int i = 0; i < num_epochs; i++) {
      auto heart_rates = stage_heart_rates[i].heart_rates;
      int min_hr = *std::min_element(heart_rates.begin(), heart_rates.end());
      int max_hr = *std::max_element(heart_rates.begin(), heart_rates.end());
      hr_epochs->push_back(HeartReport::HREpoch(min_hr, max_hr));
    }
  }
  
  
  void HeartReport::Run() {
    auto& table = rets_->table;
    auto& hr_epochs = rets_->hr_epochs;
    auto sleep_onset_epoch_id = args_->sleep_onset_epoch_id;
    auto stage_heart_rates = args_->stage_heart_rates;    

    TableIndex table_index;
    GetTableIndex(&table_index, stage_heart_rates, sleep_onset_epoch_id);
    table["MeanHRNREM"] = table_index.mean_hr_sleep_nrem;
    table["MeanHR"] = table_index.mean_hr;
    table["MaxHR"] = table_index.max_hr;
    table["MinHR"] = table_index.min_hr;
    
    // chart
    GetHREpochs(&hr_epochs, stage_heart_rates);
    
  }

  // prates
  HeartReport::StageHeartRates
  GenerateStageHeartRates(const std::vector<int>& stages,
			  const std::vector<float>& heart_rates) {
    HeartReport::StageHeartRates stage_heart_rates;
    int num_samples = heart_rates.size();
    for (int i = 0; i < num_samples; i+=30) {
      int epoch_id = i / 30;
      int stage = stages[epoch_id];
      auto st = heart_rates.begin() + i;
      auto ed = heart_rates.begin() + i + 30;
      if (i + 30 > num_samples) {
	ed = heart_rates.end();
      }
      std::vector<float> heart_rates_stage(st, ed);
      stage_heart_rates.push_back(HeartReport::StageHeartRate(stage, heart_rates_stage));
    }
    return stage_heart_rates;
  }
  
}
