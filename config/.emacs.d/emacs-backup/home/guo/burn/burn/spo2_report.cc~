
#include "burn/spo2_report.h"

#include <iostream>
#include <algorithm>
#include <numeric>

namespace burn {

  float lessIndex(const std::vector<float>& spo2, float thres) {
    float dur = 0;
    for (auto sample : spo2) {
      if (sample < thres)
	dur += 1;
    }
    float index = dur / 3600;
    return index;
  }
  
  struct MetaEpoch {
    int stage;
    float min;
    float max;
    float mean;
    float less90;
    float less85;
    float less80;

    MetaEpoch() = default;
    MetaEpoch(int stage, float min, float max, float mean,
	      float less90, float less85, float less80) {
      this->stage = stage;
      this->min = min;
      this->max = max;
      this->mean = mean;
      this->less90 = less90;
      this->less85 = less85;
      this->less80 = less80;
    }
    MetaEpoch(int stage, const std::vector<float>& spo2) {
      this->stage = stage;
      int num_samples = spo2.size();
      this->min = *std::min_element(spo2.begin(), spo2.end());
      this->max = *std::max_element(spo2.begin(), spo2.end());
      this->mean = \
	std::accumulate(spo2.begin(), spo2.end(), 0) / num_samples;
      this->less90 = lessIndex(spo2, 90);
      this->less85 = lessIndex(spo2, 85);
      this->less80 = lessIndex(spo2, 80);
    }
  };
  
  void GenerateMetaEpochs(std::vector<MetaEpoch>& meta_epochs,
			  const std::vector<float>& spo2,
			  const std::vector<int>& stages,
			  int fs=1) {
    int num_epochs = stages.size();
    int epoch_id = 0;
    int step = 30 * fs;
    for (auto it = spo2.begin(); it < spo2.end(); it += step) {
      auto end = it + step;
      if (end > spo2.end()) end = spo2.end();
      if (epoch_id >= num_epochs) {
	break;
      }
      auto stage = stages[epoch_id];
      //std::cerr << stage << '\n';
      std::vector<float> spo2_epoch(it, end);
      meta_epochs.push_back(MetaEpoch(stage, spo2_epoch));
      epoch_id += 1;
    }
    
  }    

  void GetSpo2Epochs(std::vector<Spo2Report::Spo2Epoch>& spo2_epochs,
		     const std::vector<float>& spo2,
		     int fs=1) {
    int epoch_id = 0;
    int step = 30 * fs;
    int num_epochs = spo2_epochs.size();
    for (auto it = spo2.begin(); it < spo2.end(); it += step) {
      auto end = it + step;
      if (end > spo2.end()) end = spo2.end();
      float min = *std::min_element(it, end);
      float max = *std::max_element(it, end);
      if (epoch_id >= num_epochs) break;
      spo2_epochs[epoch_id] = Spo2Report::Spo2Epoch(min, max);
      epoch_id += 1;
    }    
  }
  
  float GetMinimumSpo2LastingTimeInSec(const std::vector<float>& spo2,
				       int sleep_onset_epoch_id,
				       int fs=1) {
    int sleep_onset_start = sleep_onset_epoch_id * 30 * fs;
    int num_samples = spo2.size();
    if (num_samples < sleep_onset_start) return -1;
    float minimum = *std::min_element(spo2.begin()+sleep_onset_start, spo2.end());

    std::vector<Event> events_in_minimum;
    bool is_minimum = false;
    int start = -1;
    int end = -1;
    for (int i = sleep_onset_start; i < num_samples; i++) {
      float sample = spo2[i];
      if (!is_minimum and sample == minimum) {
	is_minimum = true;
	start = i;
      }
      if (is_minimum and sample != minimum) {
	end = i;
	events_in_minimum.push_back(Event(start, end));
	is_minimum = false;
      }
    }
    
    int max_dur_for_minimu = 0;
    for (auto event : events_in_minimum) {
      auto dur = event.end - event.start;
      if (dur > max_dur_for_minimu)
	max_dur_for_minimu = dur;
    }
    
    float max_dur_for_minimu_in_sec = max_dur_for_minimu / fs;
    return max_dur_for_minimu_in_sec;
  }
  
  float GetLongestEventDurationInSec(const std::vector<Event>& events, int fs=1) {
    float max_dur = 0;
    for (auto event : events) {
      auto dur = event.end - event.start;
      if (dur > max_dur) max_dur = dur;
    }
    return max_dur;
  }

  float GetMaximumDescrease(const std::vector<Event>& events,
			    const std::vector<float>& spo2) {
    float max_desc = 0;
    for (auto event : events) {
      auto begin = spo2.begin() + event.start;
      auto end = spo2.begin() + event.end;
      auto [min, max] = std::minmax_element(begin, end);
      auto desc = *max - *min;
      if (desc > max_desc) max_desc = desc;
    }
    return max_desc;
  }
  
  void Spo2Report::Run() {
    auto& table = rets_->table;
    auto stages = args_->stages;
    auto spo2 = args_->spo2;
    auto desats = args_->desats;
    auto sleep_onset_epoch_id = args_->sleep_onset_epoch_id;
    int num_epochs = stages.size();
    
    table["MinimumSpo2LastingTime"] = \
      GetMinimumSpo2LastingTimeInSec(spo2, sleep_onset_epoch_id);

    std::vector<MetaEpoch> meta_epochs;
    GenerateMetaEpochs(meta_epochs, spo2, stages);

    float minimum_spo2_tib = *std::min_element(spo2.begin(), spo2.end());
    table["MinimumSpo2TIB"] = minimum_spo2_tib;

    // calcuate indices from meta_epochs
    float minimum_spo2_tst = 1000;    
    float mean_spo2_tib = 0;
    float mean_spo2_rem = 0;
    int num_rem_epochs = 0;    
    float mean_spo2_nrem = 0;
    int num_nrem_epochs = 0;
    int num_wake_epochs = 0;
    float less90_wake = 0;
    float less85_wake = 0;
    float less80_wake = 0;
    float less90_rem = 0;
    float less85_rem = 0;
    float less80_rem = 0;
    float less90_nrem = 0;
    float less85_nrem = 0;
    float less80_nrem = 0;
    float less90_total = 0;
    float less85_total = 0;
    float less80_total = 0;
    for (auto meta_epoch : meta_epochs) {
      auto stage = meta_epoch.stage;
      auto min = meta_epoch.min;
      auto mean = meta_epoch.mean;
      auto less90 = meta_epoch.less90;
      auto less85 = meta_epoch.less85;
      auto less80 = meta_epoch.less80;
      if (stage != 0 and min < minimum_spo2_tst) {
	minimum_spo2_tst = min;
      }
      if (stage == 4) {
	mean_spo2_rem += mean;
	num_rem_epochs += 1;
	less90_rem += less90;
	less85_rem += less85;
	less80_rem += less80;
      }
      if (stage == 1 or stage == 2 or stage == 3) {
	mean_spo2_nrem += 1;
	num_nrem_epochs += 1;
	less90_nrem += less90;
	less85_nrem += less85;
	less80_nrem += less80;	
      }
      if (stage == 0) {
	num_wake_epochs += 1;
	less90_wake += less90;
	less85_wake += less85;
	less80_wake += less80;
      }      
      mean_spo2_tib += mean;
      less90_total += less90;
      less85_total += less85;
      less80_total += less80;
    }
    mean_spo2_tib /= num_epochs;
    mean_spo2_rem /= num_rem_epochs;
    mean_spo2_nrem /= num_nrem_epochs;
    less90_wake /= num_wake_epochs;
    less85_wake /= num_wake_epochs;
    less80_wake /= num_wake_epochs;
    less90_rem /= num_rem_epochs;
    less85_rem /= num_rem_epochs;
    less80_rem /= num_rem_epochs;
    less90_nrem /= num_nrem_epochs;
    less85_nrem /= num_nrem_epochs;
    less80_nrem /= num_nrem_epochs;
    less90_total /= num_epochs;
    less85_total /= num_epochs;
    less80_total /= num_epochs;
    table["MinimumSpo2TST"] = minimum_spo2_tst;
    table["MeanSpo2TIB"] = mean_spo2_tib;
    table["MeanSpo2REM"] = mean_spo2_rem;
    table["MeanSpo2NREM"] = mean_spo2_nrem;    
    table["Less90_Wake"] = less90_wake;
    table["Less85_Wake"] = less85_wake;
    table["Less80_Wake"] = less80_wake;
    table["Less90_REM"] = less90_rem;
    table["Less85_REM"] = less85_rem;
    table["Less80_REM"] = less80_rem;
    table["Less90_NREM"] = less90_nrem;
    table["Less85_NREM"] = less85_nrem;
    table["Less80_NREM"] = less80_nrem;
    table["Less90_Total"] = less90_total;
    table["Less85_Total"] = less85_total;
    table["Less80_Total"] = less80_total;

    std::vector<Event> desats_wake;
    std::vector<Event> desats_rem;
    std::vector<Event> desats_nrem;
    for (auto event : desats) {
      auto start = event.start;
      auto end = event.end;
      auto start_epoch_id = IndexToEpochID(start);
      auto end_epoch_id = IndexToEpochID(end);
      // TODO how to dispatch events to different stages
      for (int id = start_epoch_id; id <= end_epoch_id; id++) {
	auto stage = stages[id];
	if (stage == 0){
	  desats_wake.push_back(event);
	  break;
	}
	else if (stage == 4) {
	  desats_rem.push_back(event);
	  break;
	}
	else {
	  desats_nrem.push_back(event);
	  break;
	}
      }      
    }

    // longest, maxdesc
    table["Longest_Wake"] = GetLongestEventDurationInSec(desats_wake);
    table["Longest_NREM"] = GetLongestEventDurationInSec(desats_nrem);
    table["Longest_REM"] = GetLongestEventDurationInSec(desats_rem);
    table["Longest_Total"] = GetLongestEventDurationInSec(desats);

    table["Maxdesat_Wake"] = GetMaximumDescrease(desats_wake, spo2);
    table["Maxdesat_REM"] = GetMaximumDescrease(desats_rem, spo2);
    table["Maxdesat_NREM"] = GetMaximumDescrease(desats_nrem, spo2);
    table["Maxdesat_Total"] = GetMaximumDescrease(desats, spo2);

    //"MinimumSpo2Resp"
    float num_desats = desats.size();
    table["NumDesats"] = num_desats;
    float spo2_time_in_hour = spo2.size() / 1 / 3600;
    table["ODI"] = num_desats / spo2_time_in_hour;
    
    float less90_in_sleep_ratio = \
      (less90_rem * num_rem_epochs + less90_nrem * num_nrem_epochs) * 3600 \
      / ((num_rem_epochs + num_nrem_epochs) * 30);
    table["Less90InSleep"] = less90_in_sleep_ratio;

    auto spo2_epochs = std::vector<Spo2Epoch>(num_epochs, Spo2Epoch());
    GetSpo2Epochs(spo2_epochs, spo2);
    auto& chart_spo2 = rets_->chart_spo2;
    chart_spo2 = "Spo2,";
    for (auto spo2_epoch : spo2_epochs) {
      std::cerr << chart_spo2 << '\n';
      chart_spo2.append(std::to_string(spo2_epoch.min) + "_" +	\
			std::to_string(spo2_epoch.max) + ",");
    }

    chart_spo2[chart_spo2.size()-1] = '\n';
    
  }

}

