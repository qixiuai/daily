
""" produce dataset from physiochallengle2018 """

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import os
import numpy as np
import pandas as pd
import tensorflow as tf
import physionetchallenge2018_lib as phyc_lib

from glob import glob
from wfdb import rdann
from scipy.io import loadmat
from sklearn.model_selection import train_test_split

import pdb


class PhysionetChallengeDataset(object):

    def __init__(self, mode="Train", debug=True):
        self.data_dir = "/home/guo/physio/database/physiochallenge2018/training/"
        self.mode = mode
        self.debug = debug
        #self.seq_len = seq_len # sequence length set to be 1*30s 1*30*200=6000

    def _load_subject_label(self, subject_dir, type="stage"):
        subject_id = os.path.basename(subject_dir)
        anno = rdann(subject_dir+subject_id, extension="arousal")
        labels = []
        fs = anno.fs
        prev_sample = 0
        for ind in range(anno.ann_len):
            label = anno.aux_note[ind]
            sample = anno.sample[ind]
            if label in {"W", "N1", "N2", "N3", "R"}:
                num_epochs = (sample - prev_sample) / (30 * fs)
                labels.extend([label] * num_epochs)
                prev_sample = sample
        return labels

    def _load_subject_data(self, subject_dir):
        subject_id = os.path.basename(subject_dir)
        signal_path = os.path.join(subject_dir, subject_id+".mat")
        data = np.transpose(loadmat(signal_path)['val']).reshape(-1, 6000, 13)
        return data
    
    def load_subject(self, subject_dir):
        data = self._load_subject_data(subject_dir)
        labels = self._load_subject_label(subject_dir)
        return (data, labels)
        
    def generate_dataset(self):
        subjects = glob(self.data_dir+"*")
        train, test = train_test_split(subjects, test_size=0.4, shuffle=True, random_state=2019)
        val, test = train_test_split(test, test_size=0.5, shuffle=True, random_state=2019)
        if self.mode == "Train":
            self.subjects = train
        elif self.mode == "Validation":
            self.subjects = val
        elif self.mode == "Test":
            self.subjects = test
        else:
            raise Exception("unexpected mode")

    def __call__(self):
        for subject in self.subjects:
            data, labels = self.load_subject(subject)
            num_epochs = len(labels)
            for epoch_id in range(num_epochs):
                x = data[epoch_id]
                label = labels[epoch_id]
                yield (x, label)


if __name__ == "__main__":
    pass

