
import pdb
import os
import numpy as np
import tensorflow as tf

from matplotlib import pyplot as plt
from glob import glob
from PIL import Image

import object_detection as ob

from object_detection.utils import label_map_util
from object_detection.utils import visualization_utils as vis_util
from object_detection.utils import ops as utils_ops

from label_maps import KaggleLabelMap
from tqdm import tqdm

from absl import app
import matplotlib
matplotlib.use('Qt5Agg')


pretrained_path = "/home/guo/data/kaggle/pretrained/"
tf_model_dir = "/home/guo/Github/tensorflow_models/research/object_detection/"
FROZEN_PATH = pretrained_path + "faster_rcnn_inception_resnet_v2_atrous_oid_v4_2018_12_12/frozen_inference_graph.pb"
#LABEL_MAP_PATH = tf_model_dir + "data/oid_object_detection_challenge_500_label_map.pbtxt"
LABEL_MAP_PATH = tf_model_dir + "data/oid_v4_label_map.pbtxt"
IMAGE_SIZE = (12, 8)

def load_image_into_numpy_array(image):
    (im_width, im_height) = image.size
    return np.array(image.getdata()).reshape(
        (im_height, im_width, 3)).astype(np.uint8)


def load_frozen_model(frozen_path):
    graph = tf.Graph()
    with graph.as_default():
        graph_def = tf.GraphDef()
        with tf.gfile.GFile(frozen_path, 'rb') as fid:
            serialized_graph = fid.read()
            graph_def.ParseFromString(serialized_graph)
            tf.import_graph_def(graph_def, name="")
    return graph


'''
class Model(object):

    def __init__(self):
        self.graph = load_frozen_model(FROZEN_PATH)
        self.session = tf.Session()
        with self.graph.as_default():
            with self.session as sess:
                ops = tf.get_default_graph().get_operations()
                all_tensor_names = {output.name for op in ops for output in op.outputs}
                tensor_dict = {}
                for key in [
                        'num_detections', 'detection_boxes', 'detection_scores', 'detection_classes',
                        #'detection_masks'
                ]:
                    tensor_name = key + ':0'
                    if tensor_name in all_tensor_names:
                        tensor_dict[key] = tf.get_default_graph().get_tensor_by_name(tensor_name)
                    if 'detection_masks' in tensor_dict:
                        detection_boxes = tf.squeeze(tensor_dict['detection_boxes'], [0])                
                        real_num_detection = tf.cast(tensor_dict['num_detections'][0], tf.int32)
                        detection_boxes = tf.slice(detection_boxes, [0, 0], [real_num_detection, -1])


                detection_masks = tf.squeeze(tensor_dict['detection_masks'], [0])
                detection_masks = tf.slice(detection_masks, [0, 0, 0], [real_num_detection, -1, -1])
                detection_masks_reframed = utils_ops.reframe_box_masks_to_image_masks(
                    detection_masks, detection_boxes, image.shape[1], image.shape[2]
                )
                detection_masks_reframed = tf.cast(
                    tf.greater(detection_masks_reframed, 0.5), tf.uint8)
                tensor_dict['detection_masks'] = tf.expand_dims(
                    detection_masks_reframed, 0)

                image_tensor = tf.get_default_graph().get_tensor_by_name('image_tensor:0')
                    output_dict = sess.run(tensor_dict, feed_dict={image_tensor:image})
                    #output_dict['num_detections'] = int(output_dict['num_detections'][0])
                    output_dict['detection_classes'] = output_dict['detection_classes'][0].astype(np.int64)
                    output_dict['detection_boxes'] = output_dict['detection_boxes'][0]
                    output_dict['detection_scores'] = output_dict['detection_scores'][0]
                    #if 'detection_masks' in output_dict:
                    #    output_dict['detection_masks'] = output_dict['detection_masks'][0]
                    return output_dict
            self.session_run_fn = session_run_fn

    def run(self, image):
        output_dict = self.session_run_fn(image)
        return output_dict
'''

def run_inference_for_single_image(image, graph):
    with graph.as_default():
        with tf.Session() as sess:
            ops = tf.get_default_graph().get_operations()
            all_tensor_names = {output.name for op in ops for output in op.outputs}
            tensor_dict = {}
            for key in [
                    'num_detections', 'detection_boxes', 'detection_scores',
                    'detection_classes',
                    #'detection_masks'
            ]:
                tensor_name = key + ':0'
                if tensor_name in all_tensor_names:
                    tensor_dict[key] = tf.get_default_graph().get_tensor_by_name(tensor_name)
            if 'detection_masks' in tensor_dict:
                detection_boxes = tf.squeeze(tensor_dict['detection_boxes'], [0])                
                real_num_detection = tf.cast(tensor_dict['num_detections'][0], tf.int32)
                detection_boxes = tf.slice(detection_boxes, [0, 0], [real_num_detection, -1])

                '''
                detection_masks = tf.squeeze(tensor_dict['detection_masks'], [0])
                detection_masks = tf.slice(detection_masks, [0, 0, 0], [real_num_detection, -1, -1])
                detection_masks_reframed = utils_ops.reframe_box_masks_to_image_masks(
                    detection_masks, detection_boxes, image.shape[1], image.shape[2]
                )
                detection_masks_reframed = tf.cast(
                    tf.greater(detection_masks_reframed, 0.5), tf.uint8)
                tensor_dict['detection_masks'] = tf.expand_dims(
                    detection_masks_reframed, 0)
                '''
            image_tensor = tf.get_default_graph().get_tensor_by_name('image_tensor:0')
            output_dict = sess.run(tensor_dict, feed_dict={image_tensor:image})
            #output_dict['num_detections'] = int(output_dict['num_detections'][0])
            output_dict['detection_classes'] = output_dict['detection_classes'][0].astype(np.int64)
            output_dict['detection_boxes'] = output_dict['detection_boxes'][0]
            output_dict['detection_scores'] = output_dict['detection_scores'][0]
            #if 'detection_masks' in output_dict:
            #    output_dict['detection_masks'] = output_dict['detection_masks'][0]
    return output_dict


def get_predcition_string(result_out, kaggle_label_map):
    detection_classes_idx = result_out["detection_classes"]
    detection_classes = [ kaggle_label_map.category_index_to_kaggle_label(idx)
                          for idx in detection_classes_idx ]
    detection_scores = result_out["detection_scores"]
    detection_boxes = result_out["detection_boxes"]
    objs = []
    for cls, prob, bbox in zip(detection_classes,
                               detection_scores,
                               detection_boxes):
        if cls is None:
            continue
        if prob < 0.05:
            continue
        if prob < 0.1:
            print("remove a prob less than 0.1 class")
            continue
        ymin, xmin, ymax, xmax = bbox
        objs.extend([cls, prob, xmin, ymin, xmax, ymax])
    return " ".join(list(map(str, objs)))


def inference_on_images(image_paths, graph):
    kaggle_label_map = KaggleLabelMap()
    from datetime import datetime
    t = datetime.now().ctime()
    submit_dir="/home/guo/data/kaggle/oid/submits/"
    submit = open(submit_dir + t + "_submit.txt", 'w')
    submit.write("ImageId,PredictionString\n")
    for image_path in tqdm(image_paths):
        image_id = os.path.basename(image_path)[:-4]
        image = Image.open(image_path)
        image_np = load_image_into_numpy_array(image)
        image_np_expanded = np.expand_dims(image_np, axis=0)
        output_dict = run_inference_for_single_image(image_np_expanded, graph)
        pred_str = get_predcition_string(output_dict, kaggle_label_map)
        submit.write(image_id + ',' + pred_str + '\n')
        if False:
            vis_util.visualize_boxes_and_labels_on_image_array(
                image_np,
                output_dict['detection_boxes'],
                output_dict['detection_classes'],
                output_dict['detection_scores'],
                kaggle_label_map.category_index,
                instance_masks=output_dict.get('detection_masks'),
                use_normalized_coordinates=True,
                line_thickness=8)
            fig = plt.figure(figsize=IMAGE_SIZE)
            plt.imshow(image_np)
            plt.show()
    submit.close()

    
def main(unused_args):
    del unused_args
    detection_graph = load_frozen_model(FROZEN_PATH)
    image_dir = "/home/guo/data/kaggle/OpenImage2019/test/"
    image_paths = glob(image_dir+"*.jpg")
    inference_on_images(image_paths, detection_graph)
    
if __name__ == '__main__':
    app.run(main)
