#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
#include <numeric>
#include <boost/circular_buffer.hpp>

using std::cout;

class Quality {
  template <class T>
  using Buffer        = boost::circular_buffer<T>;
  using EntropyBuffer = Buffer<float>;
  using SignalValue   = int;
  using EntropyValue  = float;
  using QualityValue  = float;
  
private:
  const SignalValue __max_ = 4096;
  const SignalValue __min_ = 0;
  int     __num_bucket_;
  int     __window_size_;
  int     __total_counts_;
  EntropyBuffer __H_;
  
  std::vector<float> __bucket_counts_;

  /*
  EntropyValue __init_entropy(int __num_bucket) {
    float p = 1.0 / __num_bucket;
    return -p*log(p)*__num_bucket;
  }
  */
  EntropyValue __realtimeEntropyInit(SignalValue __val);  
  EntropyValue __realtimeEntropy(SignalValue __in_val, SignalValue __out_val);

  //  float __point_entropy(float prob);

  float __calcEntropyFromBucket();
  
public:
  Quality() = delete;
  explicit Quality(int __num_bucket, int __window_size);
  QualityValue realTimeQuality(SignalValue __in_val, SignalValue __out_val);
};

Quality::Quality(int __num_bucket, int __window_size) {
  __num_bucket_    = __num_bucket;
  __window_size_   = __window_size;
  __bucket_counts_ = std::vector<float>(__num_bucket_, 1);
  __H_ = EntropyBuffer(__window_size_);
  __total_counts_ = __num_bucket_;
}
/*
float Quality::__point_entropy(float prob) {
  return -prob*std::log(prob);
}
*/
float Quality::__calcEntropyFromBucket() {
  float __h = 0, __prob = 0;
  for_each(__bucket_counts_.begin(), __bucket_counts_.end(), [&](float __count){
      __prob = __count / __total_counts_;
      __h += -__prob*std::log(__prob);
    });
  return __h;
}

Quality::EntropyValue Quality::__realtimeEntropyInit(SignalValue __in_val) {
  int __in_bucket_index  = std::floor((__in_val/float(__max_))*__num_bucket_);
  __bucket_counts_[__in_bucket_index]  += 1;  
  __total_counts_ += 1;
  float __h = 0;
  __h = __calcEntropyFromBucket();
  __H_.push_back(__h);
  return __h;
}

Quality::EntropyValue Quality::__realtimeEntropy(SignalValue __in_val, SignalValue __out_val) {
  int __in_bucket_index  = std::floor((__in_val/float(__max_))*__num_bucket_);
  __bucket_counts_[__in_bucket_index] += 1;
  int __out_bucket_index = std::floor((__out_val/float(__max_))*__num_bucket_);
  __bucket_counts_[__out_bucket_index] -= 1;
  float __h = __calcEntropyFromBucket();
  __H_.push_back(__h);
  return __h;
}

float Quality::realTimeQuality(SignalValue __in_val, SignalValue __out_val) {
  if (__out_val == -1)
      __realtimeEntropyInit(__in_val);
  else {
    __realtimeEntropy(__in_val, __out_val);
  }

  float mean = std::accumulate(__H_.begin(), __H_.end(), 0.0);
  mean /= __H_.size();
  std::vector<float> __dev(__H_.size());
  for_each(__H_.begin(), __H_.end(), [&](float x){
      __dev.push_back(std::pow(x - mean, 2));
    });
  float __stddev = std::accumulate(__dev.begin(), __dev.end(), 0.0);
  __stddev /= __dev.size();
  cout << __stddev << '\n';
  return __stddev;
}


int main() {
  using namespace std;
  //  string file_path = "/home/guo/AwareCore/Giants/data/Test.txt";
  string file_path = "/home/guo/AwareCore/Giants/data/sleep704.txt";  
  fstream file(file_path);

  boost::circular_buffer<int> signal(50);
  int in_val, out_val = -1;
  int window_size = 6000;
  int num_bucket = 1000;
  Quality Q(num_bucket, window_size);
  float qvalue;
  while (true) {
    file >> in_val;
    if (signal.full())
      out_val = signal.front();
    signal.push_back(in_val);
    if (file.eof()) break;
    qvalue = Q.realTimeQuality(in_val, out_val);
    //    cout << qvalue << '\n';
  }
  return 0;
}



