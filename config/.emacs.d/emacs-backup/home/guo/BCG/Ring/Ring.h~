
#include <type_traits>
#include <memory>
#include <stdexcept>
//#include <__functional_base>
#include <vector>
#include <limits>
#include <climits>
#include <__debug>
// ring_iterator :> __wrap_iter<pointer> 


using namespace std;

template <class _Tp, class _Allocator = allocator<_Tp> >
  class Ring : private __vector_base <_Tp, _Allocator>
  {
  private:
  typedef __vector_base<_Tp, _Allocator>            __base;
  typedef allocator<_Tp>                            __default_allocator_type;

  public:
  typedef Ring                                      __self;
  typedef _Tp                                       value_type;
  typedef _Allocator                                allocator_type;
  typedef typename __base::__alloc_traits           __alloc_traits;
  typedef typename __base::reference                reference;
  typedef typename __base::const_reference          const_reference;
  typedef typename __base::size_type                size_type;
  typedef typename __base::difference_type          difference_type;
  typedef typename __base::pointer                  pointer;
  typedef typename __base::const_pointer            const_pointer;
  typedef __wrap_iter<pointer>                      iterator;  // TODO override
  typedef __wrap_iter<const_pointer>                const_iterator;
  typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;
  typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;
  
  static_assert((is_same<typename allocator_type::value_type, value_type>::value),
		"Allocator::value_type must be same type asd value_type");
  
  Ring() noexcept(is_nothrow_default_constructible<allocator_type>::value) {};
  explicit Ring(size_type __n) {
    this->__is_full_ = false;
    if (__n > 0) {
      __vallocate(__n);
      __construct_at_end(__n);
    }
  }
 
  ~Ring() {};
  
  Ring& operator=(const Ring& x);
  Ring& operator=(Ring&& x)
  noexcept(
	   allocator_type::propagate_on_container_move_assignment::value ||
	   allocator_type::is_always_equal::value);

  allocator_type get_allocator() const noexcept
  { return this->__alloc(); }
  
  iterator               begin()         noexcept;
  { return __make_iter(this->__begin_); }
  const_iterator         begin()   const noexcept;
  { return __make_iter(this->__begin_); }
  iterator               end()           noexcept;
  { return __make_iter(this->__end_); }
  const_iterator         end()     const noexcept;
  { return __make_iter(this->__end_); }

  reverse_iterator       rbegin()        noexcept
  { return reverse_iterator(end()); }
  const_reverse_iterator rbegin()  const noexcept
  { return const_reverse_iterator(end()); }
  reverse_iterator       rend()          noexcept
  { return reverse_iterator(begin()); }
  const_reverse_iterator rend()    const noexcept;
  { return const_reverse_iterator(begin()); }
  const_iterator         cbegin()  const noexcept
  { return begin(); }
  const_iterator         cend()    const noexcept
  { return end(); }
  const_reverse_iterator crbegin() const noexcept
  { return rbegin(); }
  const_reverse_iterator crend()   const noexcept
  { return rend(); }

  size_type size()     const noexcept;  
  size_type max_size() const noexcept;
  size_type capacity() const noexcept
  { return __base::capacity();}
  bool empty() const noexcept
  { return is_full ? false : this->__begin_ == this->__end_;}
  void reserve(size_type __n);
  void shrink_to_fit() noexcept;

  reference       operator[](size_type n);
  const reference operator[](size_type n) const;
  reference       at(size_type n);
  const_reference at(size_type n) const;
  
  reference       front()
  {
    _LIBCPP_ASSERT(!empty(), "front() called for empty ring");
    return is_full ? *this->__end_ : *this->__begin_;
  }
  const reference front() const
  {
    _LIBCPP_ASSERT(!empty(), "front() called for empty ring");
    return is_full ? *this->__end_ : *this->__begin_;
  }
  reference       back()
  {
    _LIBCPP_ASSERT(!empty(), "back() called for empty ring");
    if (this->__end_ == this->__begin_)
      return *(this->__end_cap_ - 1);
    return *(this->__end_ - 1);
  }
  const reference back() const
  {
    _LIBCPP_ASSERT(!empty(), "back() called for empty ring");
    if (this->__end_ == this->__begin_)
      return *(this->__end_cap_ - 1);
    return *(this->__end_ - 1);
  }
 
  value_type*       data() noexcept
  { return _VSTD::__to_raw_pointer(this->__begin_); }
  const value_type* data() const noexcept
  { return _VSTD::__to_raw_pointer(this->__begin_); }

  void push(const value_type& x)
  { push_back(x); }
  void push(value_type&& x)
  { push_back(x); }
  void push_back(const value_type& x);
  void push_back(value_type&& x);
  
  /*
  template <class... Args>
  reference emplace_back(Args&&... args);
  void pop_back();

  template <class... Args> iterator emplace(const_iterator position, Args&&... args);
  */  

  void resize(size_type sz);
  
  private:
  bool __is_full_;
  void __vallocate(size_type __n);
  void __vdeallocate() noexcept;
  void __construct_at_end(size_type __n);
  void __destruct_at_end(size_type );
  iterator       __make_iter(pointer __p)
  { return iterator(__p); }
  const_iterator __make_iter(const_pointer __p) const
  { return const_iterator(__p); }
  
  };

template <class _Tp, class _Allocator>
  Ring<_Tp, _Allocator>& Ring<_Tp, _Allocator>::operator=(const Ring& __r) {
  if (this != &__r) {
    __base::__copy_assign_alloc(__x);
    assign(__x.__begin_, __x.__end_cap_); // TODO BUG
  }
  return *this;
}

template <class _Tp, class _Allocator>
  Ring<_Tp, _Allocator>& Ring<_Tp, _Allocator>::operator=(Ring&& __r) {
  __move_assign(__r, integral_constant<bool,
		__storage_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

  
template <class _Tp, class _Allocator>
  typename vector<_Tp, _Allocator>::reference
  vector<_Tp, _Allocator>::operator[](size_type __n) {
  _LIBCPP_ASSERT(is_full || __n < size(), "ring[] index out of bounds");
  if (!is_full)
    return this->__begin_[__n];
  size_type __rem = this->__end_cap_ - this->__end_;
  if (__n < __rem)
    return this->__end_[__n];
  __n = __n - __rem;
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
  typename vector<_Tp, _Allocator>::const_reference
  vector<_Tp, _Allocator>::operator[](size_type __n) const {
  _LIBCPP_ASSERT(is_full || __n < size(), "ring[] index out of bounds");
  if (!is_full)
    return this->__begin_[__n];
  size_type __rem = this->__end_cap_ - this->__end_;
  if (__n < __rem)
    return this->__end_[__n];
  __n = __n - __rem;
  return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
  typename Ring<_Tp, _Allocator>::reference
  Ring<_Tp, _Allocator>::at(size_type __n) {
  if (!is_full && __n >= size())
    this->__throw_out_of_range();
  if (!is_full)
    return this->__begin_[__n];
  size_type __rem = this->__end_cap_ - this->__end_;
  if (__n < __rem)
    return this->__end_[__n];
  __n = __n - __rem;
  return this->__begin_[__n];  
}

template <class _Tp, class _Allocator>
  typename Ring<_Tp, _Allocator>::const_reference
  Ring<_Tp, _Allocator>::at(size_type __n) const {
  if (!is_full && __n >= size())
    this->__throw_out_of_range();
  if (!is_full)
    return this->__begin_[__n];
  size_type __rem = this->__end_cap_ - this->__end_;
  if (__n < __rem)
    return this->__end_[__n];
  __n = __n - __rem;
  return this->__begin_[__n];  
}

template <class _Tp, class _Allocator>
  void vector<_Tp, _Allocator>::resize(size_type __sz) {
  size_type __cs = size();
  if (__cs < __sz)
    this->__append(__sz - __cs); // TODO append
  else if (__cs > __sz) {
    this->__end_ = this->__begin_;
    for (size_type i = 0; i < __sz; i++) {
      *(this->__end_) = *(this->__end_ + __cs - __sz); // TODO check for better implementation
      ++this->__end_;
    }
    this->__destruct_at_end(this->__end_);
  }
}

template <class _Tp, class _Allocator>
  void Ring<_Tp, _Allocator>::reserve(size_type __n) {
  if (__n > capacity()) {
    this->__is_full_ = false;
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
    __swap_out_circular_buffer(__v);
  }
}

template <class _Tp, class _Allocator>
  size_type Ring<_Tp, _Allocator>::size() const noexcept {
  auto end = this->__end_;
  if (this->__is_full_)
    end = this->__end_cap();
  return static_cast<size_type>(end - this->__begin_);
}

template <class _Tp, class _Allocator>
  inline void Ring<_Tp, _Allocator>::push_back(const value_type& __x) {
  if (this->__end_ == this->__end_cap()) {
    this->__is_full_ = true;
    this->__end_     = this->__begin_;
    __alloc_traits::destroy(this->__alloc(), _VSTD::__to_raw_pointer(this->__begin_));
  }
  __alloc_traits::construct(this->__alloc(), _VSTD::__to_raw_pointer(this->__end_), __x); 
  ++this->__end_;
}

template <class _Tp, class _Allocator>
  inline void Ring<_Tp, _Allocator>::push_back(value_type&& __x) {
  if (this->__end_ == this->__end_cap()) {
    this->__is_full_ = true;
    this->__end_     = this->__begin_;
    __alloc_traits::destroy(this->__alloc(), _VSTD::__to_raw_pointer(this->__begin_));
  }
  __alloc_traits::construct(this->__alloc(),
			    _VSTD::__to_raw_pointer(this->__end_),
			    _VSTD::move(__x));
  ++this->__end_;
}

template <class _Tp, class _Allocator>
  void Ring<_Tp, _Allocator>::__vallocate(size_type __n) {
  if (__n > max_size())
    this->__throw_length_error();
  this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
  this->__end_cap() = this->__begin_ + __n;
}

template <class _Tp, class _Allocator>
  void Ring<_Tp, _Allocator>::__construct_at_end(size_type __n) {
  allocator_type& __a = this->__alloc();
  do {
    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));
    ++this->__end_;
    --__n;
  } while (__n > 0);
}


template <class _Tp, class _Allocator>
  typename Ring<_Tp, _Allocator>::size_type
  Ring<_Tp, _Allocator>::max_size() const noexcept {

  return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()),
			       numeric_limits<difference_type>::max());
}
