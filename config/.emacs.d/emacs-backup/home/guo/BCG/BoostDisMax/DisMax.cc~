
#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <numeric>
#include <chrono>
#include <thread>

#include <boost/circular_buffer.hpp>
#include <glog/logging.h>
#include <__debug>

template <class T>
using Buffer = boost::circular_buffer<T>;
using std::cout;
using std::endl;

struct Config {
  int Fz;
  int window_size;
  int max_window_size;
  int min_window_size;
  int u0 = 70;
  int k0 = 5;
};

class DisMax {
public:
  using Signal = Buffer<double>;
  using MovAvg = Buffer<double>;
  using MovDev = Buffer<double>;
  using MovMax = Buffer<double>;
  using MovDur = Buffer<double>;
  
  using WindowSizeType = uint32_t;
  using PeakOffset     = int32_t;
  using PeakIndex      = uint64_t;
  using PeakPeriod     = int32_t;
  using SampleIndex    = uint64_t;
  using PeakFreq       = float;
  using PotentialPeaks = std::vector<PeakIndex>;
  using PotentialDurs  = std::vector<double>;
  using Peaks          = std::vector<PeakIndex>;
  
  
  DisMax()  = default;
  ~DisMax() = default;
  explicit DisMax(const Config& config);
  PeakOffset run(int x); // int is Signal Data
  bool reset(bool is_reset);
  
private:
  Config __config_;

  Signal __signal_;
  MovAvg __movavg_;
  MovDev __movdev_;
  MovMax __movmax_;
  MovDur __dur_;
  
  PeakIndex   __last_peak_;
  PeakPeriod  __last_period_;
  SampleIndex __sample_index_;
  
  PeakFreq       __u_;
  PeakNumber     __n_;
  PotentialDurs  __potential_durs_;
  PotentialPeaks __potential_peaks_;

  Peaks __peaks_per_mimute_;
  
  double __movdev(const Signal& __signal,
		  const MovAvg& __movavg) const {
    auto __sz = __signal.size();
    double __dev = 0;
    for (int __i = 0; __i < __sz; __i++) {
      __dev += std::abs(__signal[__i] - __movavg[__i]);
    }
    __dev /= __sz;
    return __dev;
  }
  
  template <class T> double __mean(const Buffer<T>& __buf) const {
    double __sum = std::accumulate(__buf.begin(), __buf.end(), 0);
    return __sum / __buf.size();
  }

  void __adjustWindowSize(const PeakPeriod& __current_period) const ;
};

DisMax::DisMax(const Config& __config) {
  int __buf_sz    = __config.max_window_size;
  this->__config_ = __config;

  this->__signal_ = Signal(__buf_sz);
  this->__movavg_ = MovAvg(__buf_sz);
  this->__movdev_ = MovDev(__buf_sz);
  this->__movmax_ = MovMax(__buf_sz);
  this->__dur_    = MovDur(__buf_sz);
    
  this->__last_peak_    = 0;
  this->__last_period_  = 0;
  this->__sample_index_ = 0;
  
  this->__u_ = __config.u0;
  this->__n_ = __config.n0;
  this->__potential_peaks_ = PotentialPeaks(10);
  this->__potential_durs_  = PotentialDurs(10);
}

   // TODO refactor this function 
DisMax::PeakOffset DisMax::run(int __x) {
  __sample_index_ += 1;
  __signal_.push_back(__x);
  int __window_size = __config_.window_size;

  if (!__signal_.full()) __window_size = __signal_.size();

  __movavg_.push_back(__mean(__signal_));
  
  __movdev_.push_back(__movdev(__signal_,  __movavg_));

  auto __beg = __movdev_.begin() + __config_.max_window_size - __config_.window_size;
  __movmax_.push_back(*std::max_element(__beg, __movdev_.end()));

  PeakOffset __offset = 0;
  if (__sample_index_ == 1) {
    __dur_.push_back(1.0);
    return __offset;
  }
  
  double __d = 1;
  if (__movmax_.back() == *(__movmax_.end()-2)) {
    __d = __dur_.back() + 1;
  }
  __dur_.push_back(__d);

  PeakIndex  __maybe_current_peak   = __sample_index_ + 1  - __d;
  PeakPeriod __maybe_current_period = __maybe_current_peak - __last_peak_;
  
  if (__d != __config_.window_size) {
    // FIXME accumulate potential peaks
    return __offset;
  }
  __offset = 1 - __d;
  
  // check whether lost peak exits
  if (__last_peak_ != 0) {
    PeakFreq __cur_freq = 60 * __config_.Fz / __maybe_current_period;
    if (!__potential_peaks_.empty()) {
      auto __max_iter = std::max_element(__potential_durs_.begin(), __potential_durs_.end());
      auto __potential_peak_ind = __potential_durs_.begin() - __max_iter;
      PeakIndex  __potential_peak = *(__potential_peaks_.begin() + __potential_peaks_ind);
      PeakPeriod __period1 = __potential_peak - __last_peak_;
      PeakPeriod __period2 = __current_peak   - __potential_peak;
      PeakFreq __cand1_freq = 60 * __config_.Fz / __period1;
      PeakFreq __cand2_freq = 60 * __config_.Fz / __period2;
      if (__cur_freq < 0.6 * __u_) {
	__peaks_per_mimute_.push_back(__potential_peak_);
	__u_ = (__u_ * __n_ + __cand1_freq + __cand2_hr) / (__n + 2);
	__n_ += 2;
      }
    }
  }
  
  PeakIndex __current_peak = __maybe_current_peak;
  if (__last_peak_ == 0) {
    __last_peak_ = __current_peak;
    return __offset;
  }

  PeakPeriod __current_period = __maybe_current_period;
  if (__last_period_ == 0) {
    __last_period_ = __current_period;
    return __offset;
  }
  
  if (__current_peak == __last_peak_)
    return __offset;

  //  cout << __last_period_ << '\t' << __current_period << endl;

  WindowSizeType __ws = __config_.window_size;
  if (__last_period_ > 0.9*__current_period) {
    __ws = __ws - std::ceil(0.004*__config_.Fz);
    if (__ws < __config_.min_window_size)
      __ws = __config_.min_window_size;
  } else {
    __ws = __ws + std::ceil(0.016*__config_.Fz);
    if (__ws > __config_.max_window_size)
      __ws = __config_.max_window_size;
  }
  if (__ws != __config_.window_size) {
    //    LOG(INFO) << "change window size to " << __ws << endl;
  }
  __config_.window_size = __ws;

  if (__offset < 0) {
  // detected peak
    __last_peak_   = __current_peak;
    __last_period_ = __current_period;
  }
  
  //  std::this_thread::sleep_for(std::chrono::seconds(1));
  return __offset;
}

void DisMax::__adjustWindowSize(const PeakPeriod& __current_period) const {
  WindowSizeType __ws = __config_.window_size;
  if (__last_period_ > 0.9*__current_period) {
    __ws = __ws - std::ceil(0.004*__config_.Fz);
    if (__ws < __config_.min_window_size)
      __ws = __config_.min_window_size;
  } else {
    __ws = __ws + std::ceil(0.016*__config_.Fz);
    if (__ws > __config_.max_window_size)
      __ws = __config_.max_window_size;
  }
  if (__ws != __config_.window_size) {
    //    LOG(INFO) << "change window size to " << __ws << endl;
  }
  __config_.window_size = __ws;
}


int main(int argc, char* argv[]) {
  //  google::InitGoogleLogging(argv[0]);
  
  std::string data_dir  = "/home/guo/AwareCore/Giants/data/";
  std::string test_data = data_dir + "Test.txt";
  
  std::ifstream data_stream(test_data);

  if (!data_stream.is_open())
    throw std::invalid_argument("Data file not found");
  
  Config config;
  int Fz = 100;
  config.Fz = Fz;
  config.window_size = 0.3*Fz;
  config.max_window_size = 0.5*Fz;
  config.min_window_size = 0.3*Fz;
  
  DisMax dismax(config);

  int val;
  while (true) {
    data_stream >> val;
    if (data_stream.eof())
      break;
    auto offset = dismax.run(val);
    if (offset != 0)
      std::cout << offset << '\t' << val  << '\n';
  }
      
  return 0;
}
