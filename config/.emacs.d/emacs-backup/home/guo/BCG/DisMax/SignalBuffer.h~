#ifndef BCG_DISMAX_SIGNALBUFFER
#define BCG_DISMAX_SIGNALBUFFER

#include <cmath>
#include <memory>

#include "Buffer.h"

namespace DisMax {

class SignalBuffer : public Buffer<int> {
 public:
 SignalBuffer():Buffer<int>(){}
 SignalBuffer(int buffer_size):Buffer<int>(buffer_size){}

  friend std::ostream& operator<<(std::ostream& os, const SignalBuffer& buf) {
    std::cout << buf.size << std::endl;
    std::cout << "Buffer Data:" << std::endl;
    for (int i = 0; i < buf.size; i++)
      std::cout << buf[i] << '\t';
    return os;
  }
  
  float getEntropy(int num_buckets=600) {
    
    int maximum = 3300 + 1, minimum = 0;
    int val;

    // normalize data to [0 1] and divide data into 10 buckets
    std::shared_ptr<int> bucket_counts =  \
      std::shared_ptr<int>(new int[num_buckets], std::default_delete<int[]>());
    
    for (int i = 0; i < num_buckets; i++)
      bucket_counts.get()[i] = 0;
    
    float distance = maximum - minimum;
    float normalized_val;
    int bucket_index = -1;
    for (int i = 0; i < this->size; i++) {
      val = (*this)[i];
      normalized_val = (val - minimum) / distance;
      bucket_index = std::floor(normalized_val * num_buckets);
      bucket_counts.get()[bucket_index] += 1;
    }

    // calc entropy
    int count = 0;
    float entropy = 0, prob = 0;
    for (int i = 0; i < num_buckets; i++) {
      count = bucket_counts.get()[i] + 1;
      prob  = float(count) / (this->size + num_buckets);
      entropy += (-1) * prob * std::log(prob);
    }
    return entropy;
  }
  
  
  double getRMSE() {
    double rmse = 0;
    double m = this->getMean();
    int val;
    for (int i = 0; i < this->size; i++) {
      val = (*this)[i];
      rmse += std::pow(val-m, 2);
    }
    rmse = std::sqrt(rmse);
    return rmse;
  }
};

}

#endif
