
#include <algorithm>
#include <iostream>
#include <chrono>
#include <cstdint>
#include <exception>
#include <vector>
#include <string>
#include <numeric>
#include <unordered_map>
#include <utility>

#include "absl/strings/str_join.h"
#include "absl/strings/str_split.h"
#include "absl/strings/strip.h"

#include "psg/ops/edfplus.h"

EdfPlus::EdfPlus(std::string filepath) {
  std::vector<char> data;
  throw std::logic_error("Not implemented!");
}

void EdfPlus::_parse_time() {
  std::vector<char> raw_time(raw.begin()+168, raw.begin()+168+16);
  this->_starttime = Time(raw_time);
}

void EdfPlus::_parse_num_signals() {
  std::string _num_signals_str(raw.begin()+252, raw.begin()+252+4);
  this->_num_signals = std::stoi(_num_signals_str);
}

void EdfPlus::_parse_signal_names() {
  auto _name_st = raw.begin() + 256;
  auto _name_ed = _name_st + this->_num_signals * 16;
  std::string _names_raw(_name_st, _name_ed);
  std::vector<std::string> names_raw = absl::StrSplit(_names_raw, absl::ByString("  "));
  for (auto name_raw : names_raw) {
    std::string name{name_raw};
    absl::RemoveExtraAsciiWhitespace(&name);
    if (name.length() > 0) 
      this->_signal_names.push_back(name);
  }
}

void EdfPlus::_parse_signal_freqs() {
  auto _freq_st = raw.begin() + 256 + this->_num_signals * 216;
  auto _freq_ed = _freq_st + this->_num_signals * 8;
  std::string _freq_raw(_freq_st, _freq_ed);
  std::vector<std::string> freqs_raw = absl::StrSplit(_freq_raw, ' ');
  for (auto freq_raw : freqs_raw) {
    std::string freq{freq_raw};
    absl::RemoveExtraAsciiWhitespace(&freq);
    if (freq.length() > 0)
      this->_signal_freqs.push_back(std::stoi(freq));
  }
}

inline int parse_sample(char byte1, char byte2) {
  int16_t sample = static_cast<unsigned char>(byte1) |
    static_cast<unsigned char>(byte2) << 8;
  return int(sample);
}

std::vector<int> parse_samples(const std::vector<char>& record) {
    std::vector<int> samples;
    int num_bytes = record.size();
    int num_samples = num_bytes / 2;
    samples.reserve(num_samples);
    for (int i = 0; i < num_bytes; i += 2) {
      int sample = parse_sample(record[i], record[i+1]);
      samples.push_back(sample);
    }
    return samples;
};

void EdfPlus::_parse_signals() {
  // init _signals
  for ( int i = 0; i < this->_num_signals; i++ ) {
    std::vector<int> tmp;
    this->_signals.push_back(tmp);
  }
  
  // get raw signal data
  auto _st_signals = raw.begin() + 256 + this->_signal_names.size() * 256;
  std::vector<char> raw_signals(_st_signals, raw.end());

  // parse raw
  std::vector<int> samples = parse_samples(raw_signals);

  // record size
  int record_size = std::accumulate(this->_signal_freqs.begin(),
				    this->_signal_freqs.end(),
				    0);

  /*
  // cout Resp chest first 10
  int index = 5;
  int _st = std::accumulate(this->_signal_freqs.begin(),
			    this->_signal_freqs.begin() + index,
			    0);
  std::cout << this->_signal_names[index] << "\n";
  std::cout << this->_signal_freqs[index] << "\n";
  int signal_freq = this->_signal_freqs[index];
    std::cout << "---------------_" << '\n';  
  for (int i = 0; i < _st; i++) {
    std::cout << static_cast<int>(raw_signals[2*i]) << ','
      << static_cast<int>(raw_signals[2*i+1]) << ',' << samples[i] << '\n';
  }
  std::cout << "---------------_st: " << _st << '\n';  
  for (int i = _st; i < _st+10; i++) {
    std::cout << static_cast<int>(raw_signals[2*i]) << ','
      << static_cast<int>(raw_signals[2*i+1]) << ',' << samples[i] << '\n';
  }
  return;
  */
  /*  
  for (int sample_index = _st;
       sample_index < int(samples.size());
       sample_index += record_size) {
      for (int freq_index = 0; freq_index < signal_freq; freq_index++) {
	int sp = samples[sample_index + freq_index];
	std::cout << sp << ',';
      }
      break;
  }
  */
  //  std::cout << '\n';
  
  int signal_start = 0;
  for (int signal_index = 0; signal_index < this->_num_signals; signal_index++) {
    // dispatch each signal from samples
    
    int signal_freq = this->_signal_freqs[signal_index];
    
    for (int sample_index = signal_start;
	 sample_index < int(samples.size());
	 sample_index += record_size) {
      for (int freq_index = 0; freq_index < signal_freq; freq_index++) {
	int sample = samples[sample_index + freq_index];
	this->_signals[signal_index].push_back(sample);
      }
    }
    signal_start += signal_freq;
  }
  
}

void EdfPlus::_parse_data() {
  _parse_time();
  _parse_num_signals();
  _parse_signal_names();
  _parse_signal_freqs();
  _parse_signals();
}



