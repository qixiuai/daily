
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import numpy as np
import autopeaks
import plotly.graph_objs as go

from absl import app
from collections import namedtuple
from collections import deque
from itertools import product
from plotly.offline import plot
from scipy.signal import lfilter

from bcg import load_bcg

class sample(object):

    def __init__(self, index, value):
        self.index = index
        self.value = value
        self.next = []
        self.prev = []
    pass


class Peak(object):

    def __init__(self, index, value):
        self.index = index
        self.value = value
    pass


class Cycle(object):
    pass


def body_movement(signal):
    auto_peaks = autopeaks.AutoPeaks(thres=0.8, min_dist=100, fs=500, buffer_size=700)
    list(map(auto_peaks.findpeaks, signal))
    peak_indices = auto_peaks.peak_indexes
    peak_values = auto_peaks.peak_values
    base_buffer = deque(maxlen=60*5)
    in_event = False
    mts = []
    start = 0
    end = 0
    for (index, value) in zip(peak_indices, peak_values):
        base = np.median(base_buffer)
        mt_thres_start = base * 1.8
        mt_thres_end = base * 1.2
        if not in_event and value >= mt_thres_start:
            in_event = True
            start = index
        if in_event and value <= mt_thres_end:
            end = index
            mts.append(start, end)
            start = end = 0
            in_event = False
        if not in_event:
            base_buffer.append(value)
    return mts


def benchmark_model(signal):
    # 1. bandpass
    # 2. remove MT
    #
    # repeat from 1 - 3
    # 1. findpeaks from high prob to low
    # 2. mean JJ interval
    # 3. patterned error remove
    # 
    pass
    
    

def metrics(autopeaks):
    """ 
    1. quality of convergence for intervals
    2. distribution of peak values
    3. hrv variability
    """
    pass


def findpeaks_parallel(signal):
    thres = range(50, 85, 5)
    min_dist = range(100, 500, 50)
    result = []
    for (t, d) in product(thres, min_dist):
        thres = t / 100
        min_dist = d
        print(t,d)
        auto_peaks = autopeaks.AutoPeaks(thres=thres, min_dist=min_dist, fs=500)
        result.append(auto_peaks)
    return result


def merge_peaks(auto_peaks):
    """
    1. find median cycle
    2. merge by segment
    """
    pass


def main(unused_args):
    del unused_args

    # load bcg
    bcg_path = "/home/guo/BCGHeart/data/wsx_bcg_wave(500HZ).txt"
    signal = load_bcg(bcg_path, offset=12726, filter=True)

    # find peaks with best thres and min_dist
    auto_peaks = findpeaks_parallel(signal)

    # merge findpeaks results
    
    
    # peak finetune
    
    


if __name__ == '__main__':
    app.run(main)


