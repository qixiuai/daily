
#include "resp/findpeaks.h"

namespace bcg {

  namespace autopeaks {

    std::vector<int> argsort(const std::vector<int>& vec) {
      std::vector<int> indexes = std::vector<int>(vec.size());
      std::iota(indexes.begin(), indexes.end(), 0);
      std::sort(indexes.begin(), indexes.end(),
		[&vec](std::size_t i1, std::size_t i2)
		{
		  return vec[i1] > vec[i2];
		});
      return indexes;
    }

    std::vector<int> argsort(const std::vector<double>& vec) {
      std::vector<int> indexes = std::vector<int>(vec.size());
      std::iota(indexes.begin(), indexes.end(), 0);
      std::sort(indexes.begin(), indexes.end(),
		[&vec](std::size_t i1, std::size_t i2)
		{
		  return vec[i1] > vec[i2];
		});
      return indexes;
    }


    int argmax(const std::vector<int>& hist) {
      int max_value = 0;
      int max_index = -1;
      for (unsigned int i=0; i < hist.size(); i++) {
	if (hist[i] > max_value) {
	  max_value = hist[i];
	  max_index = i;
	}
      }
      return max_index;
    }

    bool AutoPeak::findpeaks(float sample) {
      bool status = true;
      signal_index_ += 1;
      update_counter_ += 1;
      signal_.push_back(sample);
      if (!signal_.full()):
	return status;
      auto update_thres = signal.size() / 2;
      if (update_counter_ < update_thres):
	return status;
      update_counter_ = 0;
      auto peaks = findpeaks::findpeaks(signal_, thres_, min_dist_);
      auto index_offset = signal_index_ - signal_.size() + 1;
      auto chosen_index_start = signal_.size() / 4;
      auto chosen_index_end = signal_.size() - signal_.size() / 4;
      auto chosen_dist = chosen_index_end - chosen_index_start;

      std::vector<Peak> chosen_peaks;
      auto filter_peaks = [&](std::vector<Peak> peaks) {
	for (auto peak : peaks) {
	  peak_index = peak.peak_index;
	  if (index_offset == 0 && peak_index < chosen_index_end) {
	    chosen_peaks.push_back(peak);
	    continue;
	  }
	  if (peak_index < chosen_index_start or peak_index >= chosen_index_end)
	    continue;
	  peak_index += index_offset;
	  peak.peak_index = peak_index;
	  chosen_peaks.push_back(peak);
	}
      }
      filter_peaks(peaks);
      
      for (auto peak: chosen_peaks) {
	peak_indices_.push_back(peak.peak_index);
      }
      
      return true;
    }

    std::vector<int> AutoPeak::fetch_peak_indices() {
      std::vector<int> peak_indices;
      for (auto index : peak_indices_)
	peak_indices.push_back(index);
      peak_indices_.clear();
      return peak_indices;
    }
    
  }
}
