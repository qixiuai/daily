#include <algorithm>
#include <chrono>
#include <fstream>
#include <string>
#include <set>
#include <vector>
#include <cstdlib>
#include <utility>
//#include "psg/lib/io/edflib.h"
#include "psg/lib/io/load_edf.h"
#include "absl/strings/match.h"
#include "absl/strings/str_split.h"
#include "spdlog/spdlog.h"
#include "insight/board.h"
#include "sleepstage/protobuf/subject.pb.h"

using namespace std;

// preprocess capslpdb, sleep-edfx, ISRUC

class AnnoParser {
public:
  AnnoParser() = default;
  AnnoParser(const std::string& filepath);
  std::pair<std::string, std::string> next_epoch();
private:
  std::ifstream ifs;
  std::string   line;
  std::vector<std::string> header;
  std::set<std::string> STAGES;
};

AnnoParser::AnnoParser(const std::string& filepath) {
  STAGES = {"W", "S1", "S2", "S3", "S4", "REM", "R"};
  ifs.open(filepath);
  if (!ifs.is_open()) {
    spdlog::error("AnnoParser cann't open {}", filepath);
  }
  while (getline(ifs, line)) {
    if (absl::StartsWith(line, "Sleep Stage")) {
	break;
    }
  }
  header = absl::StrSplit(line, '\t', absl::SkipWhitespace());
  getline(ifs, line);
}

std::pair<std::string, std::string> AnnoParser::next_epoch() {
  if (line.size() == 0)
    return std::make_pair("", "");
  std::vector<std::string> vecs = absl::StrSplit(line, '\t', absl::SkipWhitespace());
  std::string stage = vecs[0];
  std::string time  = vecs[2];
  std::pair<std::string, std::string> time_stage(time, stage);
  auto search = STAGES.find(stage);
  getline(ifs, line);
  if (search == STAGES.end()) {
    spdlog::warn("found {} not in STAGES", stage);
    return this->next_epoch();
  }
  return time_stage;
}

class SubjectWriter {
public:
  SubjectWriter() = default;
  SubjectWriter(std::string out_path);
  void push_back(std::vector<std::vector<float>> epoch, std::string stage) {
    std::pair<decltype(epoch), decltype(stage)> labeled_epoch;
    labeled_epoch.first  = epoch;
    labeled_epoch.second = stage;
    pool_epoch.push_back(labeled_epoch);
  }
  void write_to_disk();
private:
  std::ofstream ofs;
  physio::Subject subject;
  std::vector<std::pair<std::vector<std::vector<float>>, std::string>> pool_epoch;
};

SubjectWriter::SubjectWriter(std::string out_path) {
  ofs.open(out_path, std::ios_base::binary | std::ios_base::out);
  if (!ofs.is_open()) {
    spdlog::error("error happeds during create {}", out_path);
  }
  subject.set_filepath(out_path);
}

void SubjectWriter::write_to_disk() {
  for (auto pair : pool_epoch) {
    
  }
}

class EdfAnnotator {
public:
  EdfAnnotator() = default;
  EdfAnnotator(std::string edf_path, std::string anno_path);
  std::pair<std::vector<std::vector<float>>, std::string> next_epoch();
private:
  physio::io::EdfplusReader edf;
  AnnoParser anno;
};

EdfAnnotator::EdfAnnotator(std::string edf_path, std::string anno_path) {
  //  edf  = physio::io::EdfplusReader(edf_path);
  //  anno = AnnoParser(anno_path);
}

std::pair<std::vector<std::vector<float>>, std::string>
EdfAnnotator::next_epoch() {
  std::pair<std::string, std::string> time_stage = anno.next_epoch();
  std::string time  = time_stage.first;
  std::string stage = time_stage.second;
  std::tm tm = {};
  //  std::stringstream ss("Jan 9 2014 12:35:34");
  std::stringstream ss(time);
  //spdlog::info("Annotation time: {}", time);
  ss >> std::get_time(&tm, "%b %d %Y %H:%M:%S");
  auto signals = edf.get_epoch(tm);
  std::pair<decltype(signals), decltype(stage)> epoch;
  epoch.first  = signals;
  epoch.second = stage;
  return epoch;
}

int main() {
  const string data_dir  = "/home/guo/data/sleepstage/database/capslpdb/";
  const string edf_file  = "n1.edf";
  const string anno_file = "n1.txt";
  //  spdlog::info("sleepstage preprocess starts");
  const string anno_path = data_dir + anno_file;
  const string edf_path  = data_dir + edf_file;
  //  auto edf_anno = EdfAnnotator(edf_path, anno_path);
  //  edf_anno.next_epoch();
  //  SubjectWriter writer_pb("/home/guo/data/sleepstage/protobuf/n1.pb");
  //  writer_pb.write();
  
  //  spdlog::info("next_epoch: {}", anno.next_epoch());
  //  spdlog::info("sleepstage ends");
  return 0;
}
