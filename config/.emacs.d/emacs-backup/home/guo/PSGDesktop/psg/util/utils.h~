
#ifndef _PSG_UTIL_UTILS
#define _PSG_UTIL_UTILS

#include <utility>
//#include <cpprest/json.h>

//#include "absl/strings/match.h"
#include "boost/circular_buffer.hpp"
//#include "psg/api/data.h"

using namespace web;

template <typename T>
using Buffer = boost::circular_buffer<T>;

class MovMean {
public:
  MovMean() = default;
  MovMean(int window_size): window_size_{window_size} {
    buf_ = Buffer<float>(window_size);
    buf_.push_back(0);
    sum_ = 0;
  }
      
  float movMean(float sample) {
    auto front = buf_.front();
    sum_ += sample - front;
    buf_.push_back(sample);
    return sum_ / buf_.size();
  }
      
private:
  float sum_ = 0;
  int window_size_;
  Buffer<float> buf_;
};

/*
std::vector<float> get_signal_from_db(const json::value& db,
				      std::string hex_str,
				      std::string signal_name) {
  std::vector<float> signal;
  auto query = hex_str + "/signals/" + signal_name;
  auto db_obj = db.as_object();
  for (auto it = db_obj.begin(); it != db_obj.end(); it++) {
    auto key = it->first; // string
    if (key != query) continue;
    auto arr = it->second.as_array();
    for (auto it = arr.begin(); it != arr.end(); it++) {
      signal.push_back((*it).as_double());
    }
  }
  return signal;
}


using Event  = std::pair<int, int>;
using Events = std::vector<Event>;
// prefix: hash256/Events/Resp/
Events get_events_from_db(const json::value& db,
			  std::string prefix) {
  Events events;
  auto db_obj = db.as_object();
  for (auto it = db_obj.begin(); it != db_obj.end(); it++) {
    auto key = it->first;
    if (!absl::StartsWith(key, prefix)) continue;
    std::string st_str(key.begin()+prefix.length(), key.end());
    auto st = std::stoi(st_str);
    auto ed = it->second.as_integer();
    events.push_back(std::make_pair(st, ed));
  }
  std::sort(events.begin(), events.end(), [](Event p1, Event p2) {
      return p1.first < p2.first;
    });
  return events;
}



std::vector<int> get_stages_from_db(const json::value& db,
				    std::string hex_str) {
  auto query = hex_str + "/Event/Stage/";
  auto events = get_events_from_db(db, query);
  std::vector<int> stages;
  for (auto it = events.begin(); it != events.end(); it++) {
    // assert events is well sorted and data is good
    stages.push_back(it->second);
  }
  return stages;
}
*/

#endif
