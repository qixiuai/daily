
""" produce dataset from physiochallengle2018 """

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import os
import numpy as np
import pandas as pd
import tensorflow as tf
import physionetchallenge2018_lib as phyc_lib

from glob import glob
from wfdb import rdann
from scipy.io import loadmat
from sklearn.model_selection import train_test_split
from collections import namedtuple

import pdb

Symbol = namedtuple("Symbol", ["start", "end"])

class PhysionetChallengeDataset(object):

    def __init__(self, mode="train", debug=True, channels=[], step=30):
        self.data_dir = "/home/guo/physio/database/physiochallenge2018/training/"
        self.mode = mode
        self.debug = debug
        self.subjects = []
        self.channels = channels
        self.step = step
        #self.seq_len = seq_len # sequence length set to be 1*30s 1*30*200=6000
        self.generate_dataset()

    def _load_anno_labels(self, anno, symbol):
        """
        """
        total_samples = anno.sample[-1]
        labels = [0 for i in range(total_samples)]
        for ind in range(anno.ann_len):
            note = anno.aux_note[ind]
            cur_sample_id = anno.sample[ind]
            if note == symbol.start:
                start_id = cur_sample_id
            elif note == symbol.end:
                assert(start_id != -1)
                for i in range(start_id, cur_sample_id):
                    labels[i] = 1
                start_id = -1
        return labels

    def _load_subject_label(self, subject_dir):
        subject_id = os.path.basename(subject_dir)
        anno = rdann(os.path.join(subject_dir, subject_id), extension="arousal")

        #fs = anno.fs
        total_samples = anno.sample[-1]
        stage_labels = [0 for i in range(total_samples)] # sample wise label
        stage_start_id = 0
        stagenote2label = {"W":0, "N1":1, "N2":2, "N3":3, "R":4}
        for ind in range(anno.ann_len):
            note = anno.aux_note[ind]
            cur_sample_id = anno.sample[ind]
            if note in stagenote2label.keys():
                # stage label
                stage_label = stagenote2label[note]
                for i in range(stage_start_id, cur_sample_id):
                    stage_labels[i] = stage_label
                stage_start_id = cur_sample_id
        """
        arousal_symbol = Symbol('(arousal_rera', 'arousal_rera)')
        hyp_symbol = Symbol('(resp_hypopnea', 'resp_hypopnea)')
        ca_symbol = Symbol('(resp_centralapnea', 'resp_centralapnea)')
        oa_symbol = Symbol('(resp_obstructiveapnea', 'resp_obstructiveapnea)')
        ma_symbol = Symbol('(resp_mixedapnea', 'resp_mixedapnea)')
        arousal_labels = self._load_anno_labels(anno, arousal_symbol)
        hyp_labels = self._load_anno_labels(anno, hyp_symbol)
        oa_labels = self._load_anno_labels(anno, oa_symbol)
        ca_labels = self._load_anno_labels(anno, ca_symbol)
        ma_labels = self._load_anno_labels(anno, ma_symbol)
        """
        return stage_labels

    def _load_subject_data(self, subject_dir):
        subject_id = os.path.basename(subject_dir)
        signal_path = os.path.join(subject_dir, subject_id+".mat")
        data = np.transpose(loadmat(signal_path)['val'])
        return data

    def load_subject(self, subject_dir):
        data = self._load_subject_data(subject_dir)
        stage = self._load_subject_label(subject_dir)
        return (data, stage)

    def generate_dataset(self):
        subjects = glob(self.data_dir+"**/**")
        train, test = train_test_split(subjects, test_size=0.4, shuffle=True, random_state=2019)
        val, test = train_test_split(test, test_size=0.5, shuffle=True, random_state=2019)
        if self.mode == "train":
            self.subjects = train
        elif self.mode == "validation":
            self.subjects = val
        elif self.mode == "test":
            self.subjects = test
        else:
            raise Exception("unexpected mode")

    def __call__(self):
        step = self.step
        channels = self.channels
        for subject in self.subjects:
            data, stage = self.load_subject(subject)
            num_samples = len(stage)
            data = data[:num_samples, :]
            pdb.set_trace()
            num_epochs = int(len(stage) / epoch_size)
            for epoch_id in range(num_epochs):
                start = epoch_id * epoch_size
                end = start + epoch_size
                x = data[start:end,:] if not channels else data[start:end, channels]
                yield x, stage[start:end]


if __name__ == "__main__":
    dataset = PhysionetChallengeDataset(mode="train",step=30)
    for x,stage in dataset():
        print(len(stage))
        break
