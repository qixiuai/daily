#include <algorithm>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <numeric>
#include <memory>
#include <boost/circular_buffer.hpp>

#include "findpeaks.h"

using std::vector;
using std::cout;
using std::string;
template <class T>
using buffer = boost::circular_buffer<T>;
vector<int> argsort(const vector<int>& vec) {
  vector<int> indexes = vector<int>(vec.size());
  std::iota(indexes.begin(), indexes.end(), 0);
  std::sort(indexes.begin(), indexes.end(),
	    [&vec](std::size_t i1, std::size_t i2)
	    {
	      return vec[i1] > vec[i2];
	    });
  return std::move(indexes);
}

template <class T>
vector<int> get_highest_peaks(const T& signal, const vector<int>& ipks) {
  int num_peaks = ipks.size();
  vector<int> peak_values = vector<int>(num_peaks);
  for (int i=0; i < num_peaks; i++) {
    peak_values[i] = signal[ipks[i]];
  }
  auto indexes = argsort(peak_values);
  vector<int> highest = vector<int>(num_peaks);
  for (int i=0; i < num_peaks; i++) {
    highest[i] = ipks[indexes[i]];
  }
  return std::move(highest);
}

template <class T>
vector<int> findpeaks(const T& signal, float threshold, int min_dist) {
  int len = signal.size();
  int signal_max = *std::max_element(signal.begin(), signal.end());
  int signal_min = *std::min_element(signal.begin(), signal.end());
  float thres = threshold * (signal_max - signal_min) + signal_min;
  vector<int> diffs(len-1);
  for (int i = 0; i<len-1; i++) {
    diffs[i] = signal[i+1] - signal[i];
  }
  vector<int> ipks;
  for (int i = 0; i < diffs.size(); i++) {
    if (diffs[i]   > 0 &&
	diffs[i+1] < 0 &&
	signal[i] > thres) {
      ipks.push_back(i+1);
    }
  }
  if (ipks.size() <= 1 || min_dist <= 1) {
    //      return ipks;
  }

  auto highest_ipks = get_highest_peaks<T>(signal, ipks);
  auto flags = vector<bool>(signal.size(), false);
  for (const auto idx: ipks)
    flags[idx] = true;

  for (const auto ipk: highest_ipks) {
    if (flags[ipk]) {
      auto sl_st = std::max(0, ipk - min_dist);
      auto sl_ed = std::min(int(signal.size()-1), ipk + min_dist);
      for (int i=sl_st; i<=sl_ed; i++)
	flags[i] = false;
      flags[ipk] = true;
    }
  }
  vector<int> ipks_selected;
  //ipks_selected.reserve(100);
  for (int i=0; i < flags.size(); i++) {
    if (flags[i]) {
      ipks_selected.push_back(i);
    }
  }

  return std::move(ipks_selected);
}


RespiratoryDetector::RespiratoryDetector(int update_interval,
				     float threshold,
				     int min_dist,
				     int num_cycle) {
  this->__signal_          = buffer<int>(75*10);
  this->__recent_ipks_     = buffer<int>(6);
  this->__min_dist_        = min_dist;
  this->__threshold_       = threshold;
  this->__update_interval_ = update_interval;
  this->__update_clock_    = update_interval;
  this->__current_respiratory_rate_ = 0;
  this->__next_value_index_ = 0;
  this->__ipk_delay_ = 30;
}
int RespiratoryDetector::run(int value) {
  this->__signal_.push_back(value);
  this->__next_value_index_ += 1;
  this->__update_clock_ -= 1;
  if ( __update_clock_ == 0) {
    this->__real_run();
    this->__update_respiratory_rate();
    this->__update_clock_ = this->__update_interval_;
  }
  return this->__current_respiratory_rate_;
}

void print_vector(const vector<int>& vec, string info) {
  std::cout<< "\n"<<info<<":\n";
  for (auto v: vec) {
    std::cout << v << ',';
  }
  std::cout << '\n';
}
void print_buffer(const buffer<int>& vec, string info) {
  std::cout<< "\n"<<info<<":\n";
  for (auto v: vec) {
    std::cout << v << ',';
  }
  std::cout << '\n';
}
  
void RespiratoryDetector::__real_run() {
  if (!this->__signal_.full()) {
    return;
  }
  vector<int> ipks   = findpeaks<buffer<int>>(this->__signal_,
					      this->__threshold_,
					      this->__min_dist_);
  //print_vector(ipks, "ipks");
  auto signal_length = this->__signal_.size();
  int ipk_max        = signal_length - this->__ipk_delay_;
  int ipk_min        = ipk_max       - this->__update_interval_;
  int index_offset = this->__next_value_index_ - signal_length;
  /*
    std::cout << "ipk_min:" << ipk_min << ','
    << "ipk_max:" << ipk_max << ','
    << "index_offset:" << index_offset << '\n';
  */
  if (this->__recent_ipks_.size() == 0) {
    for (auto ipk : ipks) {
      if (ipk <= ipk_max)
	this->__recent_ipks_.push_back(ipk);
    }
    return;
  }
  for (auto begin = ipks.cbegin(); begin != ipks.cend(); begin++) {
    if (*begin <= ipk_min || *begin > ipk_max) {
      continue;
    }
    // ipk_min <= *begin <= ipk_max
    this->__recent_ipks_.push_back(*begin + index_offset);
  }
}

void RespiratoryDetector::__update_respiratory_rate() {
  auto num_ipks = this->__recent_ipks_.size();
  if (num_ipks < 2) {
    return;
  }
  auto first_ipk = *this->__recent_ipks_.begin();
  auto end_ipk   = *(this->__recent_ipks_.end() - 1);
  auto num_cycle = num_ipks - 1;
  float avg_resp_cycle = (end_ipk - first_ipk) / float(num_cycle) / 75.0; // seconds
  this->__current_respiratory_rate_ = 60.0/(avg_resp_cycle);
  //print_buffer(this->__recent_ipks_, "recent ipks");
}

/*

int main() {
  // respriate rate [10,40]
  // sample rate: 75
  
  using std::cout;
  using std::string;

  std::ifstream in("../data/Wuqiliu.txt");
  if (!in.is_open()) {
    cout << "file not opened!\n";
    exit(0);
  }
  string line;
  int signal_length = 75*150;
  vector<int> signal;
  signal.reserve(10000);
  int i = 0;
  while (getline(in, line)) {
    int val = std::stoi(line);
    signal.push_back(val);
    i += 1;

    if (i == signal_length) {
      break;
    }

  }
  in.close();

  /*
  for (auto s: signal)
    cout << s << ',';
  cout << '\n';
  */
/*
  cout << "signal size: " << signal.size() << '\n';

  auto detector = Physio::RespiratoryDetector();  
  for (const auto value: signal) {
    auto rate = detector.run(value);
    cout << rate <<',';
  }
  cout << '\n';

  /*
  vector<int> ipks = Physio::findpeaks<vector<int>>(signal, 0.75, 100);

  for (auto idx: ipks) {
    cout << idx << ',';
  }
  cout << '\n';
  */
/*
  return 0;
}
*/
