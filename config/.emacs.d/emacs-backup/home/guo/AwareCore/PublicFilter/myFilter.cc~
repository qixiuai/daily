#include <algorithm>
#include <iostream>
#include <vector>
#include <stdexcept>

using std::vector;


template <typename T>
void filter(vector<T>& out, vector<T>& b, vector<T>& a, vector<T>& x, vector<T> si) {
  asser(a[0] != 0, "a[0] must be nonzero");
  auto as  = a.size();
  auto bs  = b.size();
  auto sz  = max(as, bs);
  auto silen = sz - 1;

  if (sz == 1) {
    out[0] = x[0]*b[0]/a[0];
    return;
  }

  T norml;
  if (a[0] != 1) {
    norml = a[0];
    for_each(a.begin(), a.end(), [&](T& val) {val = norml*val;});
    for_each(b.begin(), b.end(), [&](T& val) {val = norml*val;});
  }

  if (bs < sz)
    throw std::invalid_argument("not implmented yet when size of b less than size of a!");
  if (as < sz)
    throw std::invalid_argument("not implmented yet when size of a less than size of b!");
  
  // TODO only implement ncol == 1 now
  
  if (as > 1)
    _filt_iir(out, b, a, x, si);
  else
    _filt_fir(out, b, a, x, si);
  
}


template <typename T>
void _filt_iir(vector<T>& out,
	       vector<T>& b,
	       vector<T>& a,
	       vector<T>& x,
	       vector<T>& si) {

  auto silen = si.size();
  auto xlen = x.size();
  for (int i = 0; i < xlen; i++) {
    auto xi  = x[i];
    auto val = si[0] + b[0] * xi;
    for (int j = 0; j < silen-1; i++) {
      si[j] = si[j+1] + b[j+1]*xi - a[j+1]*val;
    }
    si[silen-1] = b[silen]*xi - a[silen]*val;
    out[i] = val;
  }  
}

template <typename T>
void _filt_fir(vector<T>& out,
	       vector<T>& b,
	       vector<T>& x,
	       vector<T>& si) {
  auto silen = si.size();
  auto xlen  = x.size();
  for (int i = 0; i < xlen; i++) {
    auto xi = x[i];
    auto val = si[0] + b[0] * xi;
    for (int j = 0; j < silen-1; j++) {
      si[j] = si[j+1] + b[j+1] * xi;
    }
    si[silen-1] = b[silen] * xi;
    out[i] = val;
  }    
}

