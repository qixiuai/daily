#include <algorithm>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <numeric>
#include <boost/circular_buffer.hpp>

using std::vector;

namespace Physio {
  template <class T>
  using Buffer = boost::circular_buffer<T>;
 
  struct Peak {
    int value;
    int index;
  };
  
  class PeaksFinder {
  public:
    PeaksFinder(int threshold, int min_dist);
    Peak findpeaks(int value);
 
  private:
    vector<int>  signal;
    vector<Peak> peaks;
    
    int threshold;
    int min_dist;
  };

  PeaksFinder::PeaksFinder(int threshold, int min_dist) {
    this->threshold = threshold;
    this->min_dist  = min_dist;
  }

  vector<int> argsort(const vector<int>& vec) {
    vector<int> indexes = vector<int>(vec.size());
    std::iota(indexes.begin(), indexes.end(), 0);
    std::sort(indexes.begin(), indexes.end(),
	      [&vec](std::size_t i1, std::size_t i2)
	      {
		return vec[i1] > vec[i2];
	      });
    return indexes;
  }
  
  vector<int> get_highest_peaks(const vector<int>& signal, const vector<int>& ipks) {
    vector<int> peak_values = vector<int>(signal.size());
    for (const auto ipk: ipks) {
      peak_values.push_back(signal[ipk]);
    }
    auto indexes = argsort(peak_values);
    vector<int> highest = vector<int>(ipks.size());
    for (const auto idx : indexes) {
      highest.push_back(ipks[idx]);
    }
    return highest;
  }
  
  vector<int> findpeaks(const vector<int>& signal, float threshold, int min_dist) {
    int len = signal.size();
    int signal_max = *std::max_element(signal.begin(), signal.end());
    int signal_min = *std::min_element(signal.begin(), signal.end());
    float thres = threshold * (signal_max - signal_min) + signal_min;
    vector<int> diffs(len-1);
    for (int i = 0; i<len-1; i++) {
      diffs[i] = signal[i+1] - signal[i];
    }
    for (auto d: diffs) {
      std::cout << d << ',';
    }
    std::cout << '\n';
    vector<int> ipks;
    for (int i = 0; i < diffs.size(); i++) {
      if (diffs[i]   < 0 &&
	  diffs[i+1] > 0 &&
	  signal[i] > threshold) {
	ipks.push_back(i);
      }
    }

    if (ipks.size() <= 1 || min_dist <= 1) {
      return ipks;
    }

    auto highest_ipks = get_highest_peaks(signal, ipks);

    auto flags = vector<bool>(signal.size(), false);
    for (const auto idx: ipks)
      flags[idx] = true;

    for (const auto ipk: highest_ipks) {
      if (flags[ipk]) {
	auto sl_st = std::max(0, ipk - min_dist);
	auto sl_ed = ipk + min_dist + 1;
	for (int i=sl_st; i<=sl_ed; i++)
	  flags[i] = false;
	flags[ipk] = true;
      }
    }
    vector<int> ipks_selected;
    for (int i=0; i < flags.size(); i++) {
      if (flags[i])
	ipks_selected.push_back(ipks[i]);
    }

    std::cout << "AEE" << '\n';
    return ipks_selected;
  }  
}; // end namespace Peaks

int main() {
  using std::cout;
  using std::string;

  std::ifstream in("data/lizhaoxin_bcg.txt");
  if (!in.is_open()) {
    cout << "file not opened!\n";
  }
  string line;
  int signal_length = 10;
  vector<int> signal(signal_length);
  int i = 0;
  while (getline(in, line)) {
    signal[i] = std::stoi(line);
    i += 1;
    if (i == signal_length) {
      break;
    }
  }
  in.close();
  for (auto s: signal) 
    cout << s << ',';
  cout << '\n';
  auto ipks = Physio::findpeaks(signal, 0.8, 500);
  for (auto idx: ipks) {
    cout << idx << ',';
  }
  cout << '\n';
  return 0;
}
