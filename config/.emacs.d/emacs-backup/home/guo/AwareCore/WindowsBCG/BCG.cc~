#include <exception>
#include <memory>
#include <vector>
#include <string>
#include <iostream>
#include <stdexcept>
#include <thread>
#include <chrono>
#include <cmath>
#include <numeric>
#include <algorithm>
#include <list>
#include <boost/circular_buffer.hpp>

#include "BCG.h"

Quality::Quality(int __num_bucket, int __window_size) {
  __num_bucket_    = __num_bucket;
  __window_size_   = __window_size;
  __bucket_counts_ = std::vector<float>(__num_bucket_, 1);
  __signal_        = SignalBuffer(__window_size_);
  __H_             = EntropyBuffer(__window_size_);
  __total_counts_  = __num_bucket_;
}

void Quality::reset() {
  __signal_.clear();
  __H_.clear();
  __bucket_counts_ = std::vector<float>(__num_bucket_, 1);
}

float Quality::__calcEntropyFromBucket() {
  float __h = 0, __prob = 0;
  for_each(__bucket_counts_.begin(), __bucket_counts_.end(), [&](float __count){
      __prob = __count / __total_counts_;
      __h += -__prob*std::log(__prob);
    });
  return __h;
}

Quality::EntropyValue Quality::__realtimeEntropyInit(SignalValue __in_val) {
  int __in_bucket_index  = std::floor((__in_val/float(__max_))*__num_bucket_);
  __bucket_counts_[__in_bucket_index]  += 1;  
  __total_counts_ += 1;
  float __h = 0;
  __h = __calcEntropyFromBucket();
  __H_.push_back(__h);
  return __h;
}

Quality::EntropyValue Quality::__realtimeEntropy(SignalValue __in_val, SignalValue __out_val) {
  int __in_bucket_index  = std::floor((__in_val/float(__max_))*__num_bucket_);
  __bucket_counts_[__in_bucket_index] += 1;
  int __out_bucket_index = std::floor((__out_val/float(__max_))*__num_bucket_);
  __bucket_counts_[__out_bucket_index] -= 1;
  float __h = __calcEntropyFromBucket();
  __H_.push_back(__h);
  return __h;
}

int Quality::__determineQualityLevel(float __stddev) {
  if (__stddev < 0.0001)
    return 2;
  else if (__stddev < 0.0002)
    return 1;
  else if (__stddev < 0.0003)
    return 0;
  else if (__stddev < 0.0004)
    return -1;
  else
    return -2;
}
  
QualityResult Quality::realTimeQuality(SignalValue __in_val) {
  if (!__signal_.full())
    __realtimeEntropyInit(__in_val);
  else {
    auto __out_val = __signal_.front();
    __realtimeEntropy(__in_val, __out_val);
  }
  __signal_.push_back(__in_val);
  float mean = std::accumulate(__H_.begin(), __H_.end(), 0.0);
  mean /= __H_.size();
  std::vector<float> __dev(__H_.size());
  for_each(__H_.begin(), __H_.end(), [&](float x){
      __dev.push_back(std::pow(x - mean, 2));
    });
  float __stddev = std::accumulate(__dev.begin(), __dev.end(), 0.0);
  __stddev /= __dev.size();
  QualityResult result;
  result.level = __determineQualityLevel(__stddev);
  result.is_on_bed = true;
  //  std::cout << __stddev << '\n';
  return result;
}

DisMax::DisMax(const Config& __config) {
  int __buf_sz    = __config.max_window_size;
  this->__config_ = __config;

  this->__signal_ = Signal(__buf_sz);
  this->__movavg_ = MovAvg(__buf_sz);
  this->__movdev_ = MovDev(__buf_sz);
  this->__movmax_ = MovMax(__buf_sz);
  this->__dur_    = MovDur(__buf_sz);
    
  this->__last_peak_    = 0;
  this->__last_period_  = 0;
  this->__sample_index_ = 0;
  
  this->__u_ = __config.u0;
  this->__n_ = __config.n0;
  this->__potential_peaks_ = PotentialPeaks(10);
  this->__potential_durs_  = PotentialDurs(10);
}

void  DisMax::reset() {
  __signal_.clear();
  __movavg_.clear();
  __movdev_.clear();
  __movmax_.clear();
  __dur_.clear();
  __last_peak_    = 0;
  __last_period_  = 0;
  __sample_index_ = 0;
  
  __u_ = __config_.u0;
  __n_ = __config_.n0;
  __potential_peaks_.clear();
  __potential_durs_.clear();
}
  
int DisMax::__getRatePerMinute(int __sample_index) {
  if (__peaks_per_mimute_.empty())
    return __u_;
  if (__sample_index_ <= 60*__config_.Fz)
    return __u_;
  if (__sample_index_ - __peaks_per_mimute_.front() > 60*__config_.Fz) {
    __peaks_per_mimute_.pop_front();
  }
  return __peaks_per_mimute_.size();
}
  
// TODO refactor this function 
DisMaxResult DisMax::run(int __x) {    
  __sample_index_ += 1;
  __signal_.push_back(__x);
  int __window_size = __config_.window_size;

  if (!__signal_.full()) __window_size = __signal_.size();

  __movavg_.push_back(__mean(__signal_));
  
  __movdev_.push_back(__movdev(__signal_,  __movavg_));

  auto __beg = __movdev_.begin() + __config_.max_window_size - __config_.window_size;
  __movmax_.push_back(*std::max_element(__beg, __movdev_.end()));

  PeakOffset __offset = 0;
  DisMaxResult __result;
  if (__sample_index_ == 1) {
    // for the first sample
    __dur_.push_back(1.0);
    __result.rate = __getRatePerMinute(__sample_index_);
    __result.offset = __offset;
    return __result;
  }
  
  double __d = 1;
  if (__movmax_.back() == *(__movmax_.end()-2)) {
    __d = __dur_.back() + 1;
  }
  __dur_.push_back(__d);

  PeakIndex  __maybe_current_peak   = __sample_index_ + 1  - __d;
  PeakPeriod __maybe_current_period = __maybe_current_peak - __last_peak_;
  
  if (__d != __config_.window_size) {
    double __prev_d = *(__dur_.end() - 2);
    PeakIndex __prev_potential_peak = __sample_index_ - 1 + 1 - __prev_d;
    if (__d < __prev_d && __last_peak_ != __prev_potential_peak
	&& __prev_d != __config_.window_size) {
      __potential_peaks_.push_back(__prev_potential_peak);
    }
    __result.rate   = __getRatePerMinute(__sample_index_);
    __result.offset = __offset;
    return __result;
  }
  __offset = 1 - __d;

  PeakIndex  __current_peak = __maybe_current_peak;
  if (__last_peak_ == 0) {
    // for the first time  detect Peak
    __last_peak_   = __current_peak;
    __result.rate = __getRatePerMinute(__sample_index_);
    __result.offset = __offset;
    return __result;      
  }
  if (__current_peak == __last_peak_) {
    __result.rate = __getRatePerMinute(__sample_index_);      
    __result.offset = 0;
    return __result;
  }
  __last_peak_ = __current_peak;
  PeakPeriod __current_period = __maybe_current_period;
  // check whether lost peak exits
  PeakFreq __cur_freq = 60 * __config_.Fz / __current_period;
  if (!__potential_peaks_.empty()) {
    auto __max_iter = std::max_element(__potential_durs_.begin(),
				       __potential_durs_.end());
    auto __potential_peak_ind = __potential_durs_.begin() - __max_iter;
    PeakIndex  __potential_peak = *(__potential_peaks_.begin() + __potential_peak_ind);
    PeakPeriod __period1 = __potential_peak - __last_peak_;
    PeakPeriod __period2 = __current_peak   - __potential_peak;
    PeakFreq __cand1_freq = 60 * __config_.Fz / __period1;
    PeakFreq __cand2_freq = 60 * __config_.Fz / __period2;
    if (__cur_freq < 0.6 * __u_) {
      // TODO wrap it to a function or constexp
      __peaks_per_mimute_.push_back(__potential_peak);
      __peaks_per_mimute_.push_back(__current_peak);
      __u_ = (__u_ * __n_ + __cand1_freq + __cand2_freq) / (__n_ + 2);
      __n_ += 2;
    } else {
      __peaks_per_mimute_.push_back(__current_peak);
      __u_ = (__u_ * __n_ + __cur_freq) / (__n_ + 1);
      __n_ += 1;
    }
    __potential_peaks_.clear();
  } else {
    __peaks_per_mimute_.push_back(__current_peak);
    __u_ = (__u_ * __n_ + __cur_freq) / (__n_ + 1);
    __n_ += 1;
  }  
  //    cout << __u_ << '\n';      
  if (__last_period_ == 0) {
    // For the second time detected Peak
    __last_period_ = __current_period;
    __result.rate = __getRatePerMinute(__sample_index_);
    __result.offset = __offset;
    return __result;
  }

  WindowSizeType __ws = __config_.window_size;
  if (__last_period_ > 0.9*__current_period) {
    __ws = __ws - std::ceil(0.004*__config_.Fz);
    if (__ws < __config_.min_window_size)
      __ws = __config_.min_window_size;
  } else {
    __ws = __ws + std::ceil(0.016*__config_.Fz);
    if (__ws > __config_.max_window_size)
      __ws = __config_.max_window_size;
  }
  // LOG(INFO, __ws != __config_.window_size) << "change window size to " << __ws << endl;
  __config_.window_size = __ws;
  
  __last_period_ = __current_period;  
  //  std::this_thread::sleep_for(std::chrono::seconds(1));
  __result.rate = __getRatePerMinute(__sample_index_);
  __result.offset = __offset;
  return __result;
}
 
  
  
BCGResult::BCGResult() {
  this->quality_level        = -2;
  this->is_on_bed            = false;
  this->heart_rate           = 0;
  this->heart_offset         = 0;
  this->respiratory_rate     = 0;
  this->respiratory_offset   = 0;
}


  std::ostream& operator<<(std::ostream& os, const BCGResult& result) {
  auto on_pillow = result.is_on_bed ? "true" : "false";
  os <<"-----------------------------------------------------------\n";
  os << "SignalQuality:       " << result.quality_level        << '\n' \
  << "IsOnBed:             " << on_pillow                   << '\n' \
  << "HeartRate:           " << result.heart_rate           << '\n' \
  << "HeartPosition:       " << result.heart_offset         << '\n' \
  << "RespiratoryRate:     " << result.respiratory_rate     << '\n' \
  << "RespiratoryPosition: " << result.respiratory_offset   << '\n';
  os <<"-----------------------------------------------------------\n";
  return os;
  }  


BCGFramework::BCGFramework(int __Fz) {
  this->__Fz_ = __Fz;
    
  int __num_bucket = 1000, __quality_window_size = 6*__Fz;
  this->__quality_ = Quality(__num_bucket, __quality_window_size);
    
  Config __heart_config;
  __heart_config.Fz = __Fz;
  __heart_config.window_size = 0.3*__Fz;
  __heart_config.max_window_size = 0.5*__Fz;
  __heart_config.min_window_size = 0.3*__Fz;
  __heart_config.u0 = 70;
  __heart_config.n0 = 60;
  this->__heart_dismax_ = DisMax(__heart_config);
    
  Config __respiratory_config;
  __respiratory_config.Fz = __Fz;
  __respiratory_config.window_size = 2*__Fz;
  __respiratory_config.max_window_size = 2.6*__Fz;
  __respiratory_config.min_window_size = 1.5*__Fz;
  __respiratory_config.u0 = 15;
  __respiratory_config.n0 = 15;
  this->__respiratory_dismax_ = DisMax(__respiratory_config);
}
  
BCGResult BCGFramework::run(int __value, bool __is_reset) {
  if (__is_reset) {
    __quality_.reset();
    __heart_dismax_.reset();
    __respiratory_dismax_.reset();
  }
    
  // std::cout << "BCGFramework::Run:" << __value << std::endl;

  __runQuality(__value);
    
  if (!__result_.is_on_bed) return __result_;
    
  // if (!__isSignalGood()) return __result_;

  __runHeartDisMax(__value);
    
  __runRespiratoryDisMax(__value);
      
  return __result_;
}

void BCGFramework::__runQuality(int __value) {
  QualityResult __quality_result = __quality_.realTimeQuality(__value);
  __result_.quality_level = __quality_result.level;
  __result_.is_on_bed = __quality_result.is_on_bed;
}
  
void BCGFramework::__runHeartDisMax(int __value) {
  DisMaxResult __heart_result = __heart_dismax_.run(__value);
  __result_.heart_rate = __heart_result.rate;
  __result_.heart_offset = __heart_result.offset;
}

void BCGFramework::__runRespiratoryDisMax(int __value) {
  DisMaxResult __respiratory_result = __respiratory_dismax_.run(__value);
  __result_.respiratory_rate   = __respiratory_result.rate;
  __result_.respiratory_offset = __respiratory_result.offset;
}

//} // end namespace AwareTech
