#ifndef _FILTER_
#define _FILTER_

#include <algorithm>
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <boost/circular_buffer.hpp>

namespace physio {

template <class T>
using Buffer = boost::circular_buffer<T>;

template <class T>
class Filter {
public:
  Filter() {}
  Filter(std::string B_path, std::string A_path);
  Filter(std::vector<double> B, std::vector<double> A);
  double realtime_filter(T value);
private:
  std::vector<double> B;
  std::vector<double> A;
  buffer<T>      X;
  buffer<double> Y;
};

template <class T>
class MedianFilter {
public:
  MedianFilter() {}
  MedianFilter(int kernel_size){
    this->kernel_size = kernel_size;
    this->X = buffer<T>(kernel_size);
  }
  double realtime_filter(T value);
  
private:  
  buffer<T> X;
  int kernel_size;
};

static std::vector<double> load_csv(std::string path) {
  std::fstream in(path);
  if (!in.is_open()) {
    std::cout << path << " not found!" << std::endl;
    exit(0);
  }
  std::vector<double> coeff;
  std::string line;
  while (getline(in, line)) {
    std::string val_str = "";    
    while (line.length() > 0) {
      if (line[0] == ',') {
	coeff.push_back(std::stof(val_str));
	val_str = "";
      } else {
	val_str += line[0];
      }
      line = line.substr(1);
    }
    if (val_str.length() > 0) {
      coeff.push_back(std::stof(val_str));
    }
  }
  return coeff;
}

template <class T>
Filter<T>::Filter(std::vector<double> B, std::vector<double> A){
  this->B = B;
  this->A = A;
  this->X = buffer<T>(B.size());
  this->Y = buffer<double>(A.size());
}

template <class T>
Filter<T>::Filter(std::string B_path, std::string A_path) {
  auto B = load_csv(B_path);
  auto A = load_csv(A_path);
  this->B = B;
  this->A = A;
  this->X = buffer<T>(B.size());
  this->Y = buffer<double>(A.size()-1);
}

template <class T>
double Filter<T>::realtime_filter(T value) {
  this->X.push_back(value);
  double upper, lower;
  upper = lower = 0;
  int nb = this->B.size();
  int na = this->A.size();
  int nx  = this->X.size()-1;
  int ny  = this->Y.size();
  for (int i=0; nx-i>=0 && i<nb; i++) {
    upper += this->B[i]*this->X[nx-i];
  }
  for (int i=1; ny-i>=0 && i<na; i++) {
    lower += this->A[i]*this->Y[ny-i];
  }
  double y = upper - lower;
  this->Y.push_back(y);
  return y;
}

template <class T>
double MedianFilter<T>::realtime_filter(T value) {
  this->X.push_back(value);
  if (this->X.size() <= 1)
    return double(value);
  std::vector<T> vec;
  vec.reserve(this->X.size());
  for (auto x : this->X)
    vec.push_back(x);
  int vec_size = vec.size();
  std::sort(vec.begin(), vec.end());
  return vec[vec_size/2];
}

}

#endif
