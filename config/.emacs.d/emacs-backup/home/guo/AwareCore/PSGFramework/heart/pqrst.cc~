#include <cmath>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <numeric>
#include <memory>
#include <cstdlib>

#include "utils/utils.h"

#include "pqrst.h"


namespace physio { 

template <class T>
std::vector<int> findpeaks(const T& signal, float threshold, int min_dist);
  
  PQRSTDetector::PQRSTDetector(int Fz,
			       int buffer_size,
			       int num_cycles) {
  
    int num_peaks              = num_cycles + 1;
    this->q_ipks               = Buffer<int>(num_peaks);
    this->r_ipks               = Buffer<int>(num_peaks);
    this->s_ipks               = Buffer<int>(num_peaks);
    this->p_freq               = Buffer<int>(num_peaks);
  
    this->__Fz_                = Fz;
    this->__buffer_size_       = buffer_size;
    this->__signal_            = Buffer<int>(buffer_size);

    int update_interval        = Fz*1;
    this->__update_interval_   = update_interval;
    this->__update_clock_      = update_interval;
    this->__next_value_index_  = 0;
    this->__ipk_delay_         = 100;
  }

  int PQRSTDetector::run(double value) {
    this->__signal_.push_back(value);
    this->__next_value_index_ += 1;
    this->__update_clock_ -= 1;
    if (this->__update_clock_ == 0) {
      this->__real_run();
      this->__update_clock_ = this->__update_interval_;
    }
    return 0;
  }

  void PQRSTDetector::__real_run() {
    if (!this->__signal_.full()) {
      return;
    }

    std::vector<int> q_ipks_buffer;
    std::vector<int> r_ipks_buffer;
    std::vector<int> s_ipks_buffer;
    findpeaks<Buffer<double>>(q_ipks_buffer,
			      r_ipks_buffer,
			      s_ipks_buffer,
			      this->__signal_,
			      0.8,
			      100);
    auto signal_length = this->__signal_.size();
    int ipk_max        = signal_length - this->__ipk_delay_;
    int ipk_min        = ipk_max       - this->__update_interval_;
    int index_offset   = this->__next_value_index_ - signal_length;

    if (this->r_ipks.size() == 0) {
      for (int i=0; i<r_ipks_buffer.size(); i++) {
	auto r_ipk = r_ipks_buffer[i];
	if (r_ipk <= ipk_max) {
	  auto q_ipk = q_ipks_buffer[i];
	  auto s_ipk = s_ipks_buffer[i];
	  this->q_ipks.push_back(q_ipk);
	  this->r_ipks.push_back(r_ipk);
	  this->s_ipks.push_back(s_ipk);
	}
      }
      return;
    }

    for (int i=0; i<r_ipks_buffer.size(); i++) {
    //for (auto begin = ipks.cbegin(); begin != ipks.cend(); begin++) {
      auto r_ipk = r_ipks_buffer[i];
      if (r_ipk <= ipk_min || r_ipk > ipk_max) {
      //      if (*begin <= ipk_min || *begin > ipk_max) {
	continue;
      }
      //      this->r_ipks.push_back(*begin + index_offset);
      this->r_ipks.push_back(r_ipk);
      // update q s
    }
  }

  
/*
  
template <class T>
vector<int> diff(const T& ipks) {
  vector<int> rets(ipks.size()-1);
  for (uint i=0; i<ipks.size()-1; i++) {
    rets[i] = ipks[i+1] - ipks[i];
  }
  return rets;
}

template <class T>
vector<int> np_abs_diff(const T& ipks) {
  auto diffs = np_diff(ipks);
  vector<int> abs_diffs;
  abs_diffs.reserve(diffs.size());
  std::transform(diffs.begin(), diffs.end(), std::back_inserter(abs_diffs),
		 [](int diff) -> int { return std::abs(diff); } );
  return abs_diffs; 
}
*/

std::vector<int> argsort(const std::vector<int>& vec) {
  std::vector<int> indexes = std::vector<int>(vec.size());
  std::iota(indexes.begin(), indexes.end(), 0);
  std::sort(indexes.begin(), indexes.end(),
	    [&vec](std::size_t i1, std::size_t i2)
	    {
	      return vec[i1] > vec[i2];
	    });
  return std::move(indexes);
}

std::vector<int> argsort(const std::vector<double>& vec) {
  std::vector<int> indexes = std::vector<int>(vec.size());
  std::iota(indexes.begin(), indexes.end(), 0);
  std::sort(indexes.begin(), indexes.end(),
	    [&vec](std::size_t i1, std::size_t i2)
	    {
	      return vec[i1] > vec[i2];
	    });
  return std::move(indexes);
}

template <class T>
std::vector<int> get_highest_peaks(const T& signal, const std::vector<int>& ipks) {
  int num_peaks = ipks.size();
  std::vector<double> peak_values = std::vector<double>(num_peaks);
  for (int i=0; i < num_peaks; i++) {
    peak_values[i] = signal[ipks[i]];
  }
  auto indexes = argsort(peak_values);
  std::vector<int> highest = std::vector<int>(num_peaks);
  for (int i=0; i < num_peaks; i++) {
    highest[i] = ipks[indexes[i]];
  }
  return std::move(highest);
}

template <class T>
void findpeaks(std::vector<int>& ipks_selected, std::vector<double>& diffs,
	       const T& signal, float threshold, int min_dist) {
  int len = signal.size();
  double signal_max = *std::max_element(signal.begin(), signal.end());
  double signal_min = *std::min_element(signal.begin(), signal.end());
  float thres = threshold * (signal_max - signal_min) + signal_min;
  //  std::vector<double> diffs(len-1);
  for (int i = 0; i<len-1; i++) {
    auto val = signal[i+1] - signal[i];
    diffs.push_back(val);
  }
  std::vector<int> ipks;
  for (uint32 i = 0; i < diffs.size(); i++) {
    if (diffs[i]   >= 0 &&
	diffs[i+1] <= 0 &&
	signal[i] > thres) {
      ipks.push_back(i+1);
    }
  }
  if (ipks.size() <= 1 || min_dist <= 1) {
    return std::move(ipks);
  }

  auto highest_ipks = get_highest_peaks<T>(signal, ipks);
  auto flags = std::vector<bool>(signal.size(), false);
  for (const auto idx: ipks)
    flags[idx] = true;

  for (const auto ipk: highest_ipks) {
    if (flags[ipk]) {
      auto sl_st = std::max(0, ipk - min_dist);
      auto sl_ed = std::min(int(signal.size()-1), ipk + min_dist);
      for (int i=sl_st; i<=sl_ed; i++)
	flags[i] = false;
      flags[ipk] = true;
    }
  }  

  ipks_selected.reserve(128);
  for (uint32 i=0; i < flags.size(); i++) {
    if (flags[i]) {
      ipks_selected.push_back(i);
    }
  }
  return;
}
  /*
    int argmax(const std::vector<int>& hist) {
    int max_value = 0;
    int max_index = -1;
    for (uint32 i=0; i < hist.size(); i++) {
    if (hist[i] > max_value) {
    max_value = hist[i];
    max_index = i;
    }
    }
    return max_index;
    }

    int get_median(std::vector<int> vec) {
    int vec_size = vec.size();
    assert(vec_size>=1);
    if (vec_size == 1)
    return vec[0];
    std::sort(vec.begin(), vec.end());  
    auto div_ret = div(vec_size, 2);
    if (div_ret.rem == 0)
    return vec[vec_size/2];
    auto v1 = vec[vec_size/2];
    auto v2 = vec[vec_size/2-1];
    return (v1+v2)/ 2.0;
    }

  int get_most_common(const std::vector<int>& cycles, int num_bins=10) {
    assert(cycles.size() >= 1);
    if (cycles.size() == 1) {
      return cycles[0];
    }
    if (cycles.size() <= 5) {
      return get_median(cycles);
    }
  
    int min = *std::min_element(cycles.begin(), cycles.end());
    int max = *std::max_element(cycles.begin(), cycles.end());
    float bin_len = (max - min+1) / float(num_bins-1);

    std::vector<int> histarr(num_bins, 0); // index -- count
    for (const auto cycle : cycles) {
      int bin_id = (cycle - min) / bin_len;
      histarr[bin_id] += 1;
    }
    int max_bin_id = argmax(histarr);

    std::vector<int> selected_cycles;
    float bin_lower = min + bin_len * max_bin_id;
    float bin_upper = min + bin_len * (max_bin_id + 1);
    for (auto cycle: cycles) {
      if (cycle >= bin_lower && cycle < bin_upper)
	selected_cycles.push_back(cycle);
    }
    //  print_std::vector(selected_cycles, "selected_cycles");
    int avg_cycle = get_median(selected_cycles);
    //  std::cout << "avg_cycle:" << avg_cycle << std::endl;
    return avg_cycle;
  }
  

    PQRSTDetector::PQRSTDetector(int Fz,
    int buffer_size,
    int update_interval,
    float threshold,
    int min_dist,
    int num_peaks) {
    this->__Fz_              = Fz;
    this->__buffer_size_     = buffer_size;
    this->__signal_          = Buffer<double>(buffer_size);
    this->recent_ipks        = Buffer<int>(num_peaks);
    this->cycles             = Buffer<int>(num_peaks);
    this->__min_dist_        = min_dist;
    this->__threshold_       = threshold;
    this->__update_interval_ = update_interval;
    this->__update_clock_    = update_interval;
    this->__current_peak_rate_ = 0;
    this->__next_value_index_  = 0;
    this->__ipk_delay_ = 30;
    }

    void PQRSTDetector::__update_peak_rate() {
    auto num_ipks = this->recent_ipks.size();
    if (num_ipks < 2) {
    return;
    }
    // TODO optimize cycles realtime
    std::vector<int> cycles_vec = np_abs_diff<Buffer<int>>(this->recent_ipks);
    this->cycles.push_back(0);
    for (auto c : cycles_vec) {
    this->cycles.push_back(c);
    }
    auto avg_cycle = get_most_common(cycles);
    this->__current_peak_rate_ = round(60.0 * this->__Fz_ / avg_cycle);
    }
  */
}
