#include <algorithm>
#include <cmath>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <numeric>
#include <memory>
#include <cstdlib>

#include "utils/utils.h"

#include "pqrst.h"


namespace physio { 

template <class T>
std::vector<int> findpeaks(const T& signal, float threshold, int min_dist);
  
  PQRSTDetector::PQRSTDetector(int Fz,
			       int buffer_size,
			       int num_cycles) {
  
    int num_peaks              = num_cycles + 1;
    this->q_ipks               = Buffer<int>(num_peaks);
    this->r_ipks               = Buffer<int>(num_peaks);
    this->s_ipks               = Buffer<int>(num_peaks);
    this->p_freq               = Buffer<int>(num_peaks);
  
    this->__Fz_                = Fz;
    this->__buffer_size_       = buffer_size;
    this->__signal_            = Buffer<int>(buffer_size);

    int update_interval        = Fz*1;
    this->__update_interval_   = update_interval;
    this->__update_clock_      = update_interval;
    this->__next_value_index_  = 0;
    this->__ipk_delay_         = 100;
  }

  int PQRSTDetector::run(double value) {
    this->__signal_.push_back(value);
    this->__next_value_index_ += 1;
    this->__update_clock_ -= 1;
    if (this->__update_clock_ == 0) {
      this->__real_run();
      this->__update_clock_ = this->__update_interval_;
    }
    return 0;
  }

  void PQRSTDetector::__real_run() {
    if (!this->__signal_.full()) {
      return;
    }

    std::vector<int> q_ipks_buffer;
    std::vector<int> r_ipks_buffer;
    std::vector<int> s_ipks_buffer;
    findpeaks<Buffer<double>>(q_ipks_buffer,
			      r_ipks_buffer,
			      s_ipks_buffer,
			      this->__signal_,
			      0.8,
			      100);
    
    auto signal_length = this->__signal_.size();
    int ipk_max        = signal_length - this->__ipk_delay_;
    int ipk_min        = ipk_max       - this->__update_interval_;
    int index_offset   = this->__next_value_index_ - signal_length;

    if (this->r_ipks.size() == 0) {
      for (int i=0; i<r_ipks_buffer.size(); i++) {
	auto r_ipk = r_ipks_buffer[i];
	if (r_ipk <= ipk_max) {
	  auto q_ipk = q_ipks_buffer[i];
	  auto s_ipk = s_ipks_buffer[i];
	  this->q_ipks.push_back(q_ipk);
	  this->r_ipks.push_back(r_ipk);
	  this->s_ipks.push_back(s_ipk);
	}
      }
      return;
    }

    for (int i=0; i<r_ipks_buffer.size(); i++) {
      auto r_ipk = r_ipks_buffer[i];
      if (r_ipk <= ipk_min || r_ipk > ipk_max) {
	continue;
      }
      auto q_ipk = q_ipks_buffer[i];
      auto s_ipk = s_ipks_buffer[i];
      this->r_ipks.push_back(r_ipk);
      this->q_ipks.push_back(q_ipk);
      this->s_ipks.push_back(s_ipk);
    }
  }

  template <class T>
  void findpeaks(std::vector<int>& q_ipks,
		 std::vector<int>& r_ipks,
		 std::vector<int>& s_ipks,
		 const T& signal,
		 float threshold,
		 int min_dist) {
    int len = signal.size();
    double signal_max = *std::max_element(signal.begin(), signal.end());
    double signal_min = *std::min_element(signal.begin(), signal.end());
    double thres = threshold * (signal_max - signal_min) + signal_min;
    std::vector<double> diffs(len-1);
    for (int i = 0; i<len-1; i++) {
      auto val = signal[i+1] - signal[i];
      diffs.push_back(val);
    }
    std::vector<int> ipks, highest_ipks;
    for (uint32 i = 0; i < diffs.size(); i++) {
      if (diffs[i]   >= 0 &&
	  diffs[i+1] <= 0 &&
	  signal[i+1] >= thres) {
	ipks.push_back(i+1);
	highest_ipks.push_back(i+1);
      }
    }
    if (ipks.size() < 1) {
      return;
    }

    std::sort(highest_ipks.begin(),
	      highest_ipks.end(),
	      [&signal](int ipk1, int ipk2){
		return signal[ipk1] > signal[ipk2];
	      });
  
    auto flags = std::vector<bool>(signal.size(), false);
    for (const auto idx: ipks)
      flags[idx] = true;

    for (const auto ipk: highest_ipks) {
      if (flags[ipk]) {
	auto sl_st = std::max(0, ipk - min_dist);
	auto sl_ed = std::min(int(signal.size()-1), ipk + min_dist);
	for (int i=sl_st; i<=sl_ed; i++)
	  flags[i] = false;
	flags[ipk] = true;
      }
    }  
  
    for (uint32 i=0; i < flags.size(); i++) {
      if (flags[i]) {
	r_ipks.push_back(i);
      }
    }
  
    for (auto r_ipk : r_ipks) {
      for (int ind_q=r_ipk; ind_q>=0; ind_q--) {
	if (diffs[ind_q-1] < 0) {
	  q_ipks.push_back(ind_q);
	}
      }
      for (int ind_s=r_ipk; ind_s>=0; ind_s--) {
	if (diffs[ind_s-1] > 0 ) {
	  s_ipks.push_back(ind_s);
	}
      }
    }
    return;
  }

}
