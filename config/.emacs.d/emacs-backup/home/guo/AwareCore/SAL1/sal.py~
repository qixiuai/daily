import os
from collections import namedtuple
from scipy.signal import hilbert
import numpy as np

QualityResult = namedtuple("QualityResult", ["is_on_bed", "quality_level"]);

class Quality:
    def __init__(self, Fz):
        self.__window_size_ = Fz*1;
        self.__signal_      = []
        self.__stddev_      = []
        self.__len_         = 0
        
    def run(self, x):
        self.__signal_.append(x);
        self.__stddev_.append(np.std(self.__signal_));
        self.__len_ += 1
        if self.__len_ > self.__window_size_:
            self.__signal_.pop(0);
            self.__stddev_.pop(0);
            self.__len_ -= 1

    def get_result(self):
        result = QualityResult();
        if self.__stddev_[-1] < 60:
            result.is_on_bed = False;
            result.quality_level = -2;
        else:
            result.is_on_bed = True;
            result.quality_level = self.__determine_level(self.__stddev_);

    def __determine_level(self, __stddev):
        std2 = np.std(__stddev)
        if (std2 < 1): # TODO determined with real data
            return -2;
        elif (std2 < 2):
            return -1;
        elif (std2 < 3):
            return 0;
        elif (std2 < 4):
            return 1;
        else:
            return 2;
        
    def plt_show(self):
        plt.figure();
        t = range(self.__len_);
        plt.plot(t, self.__signal_, 'b');
        plt.plot(t, self.__stddev_, 'r');
        plt.plot(t, [60 for x in t], 'g');
        plt.show();

class SmoothFilter:
    """
    smooth extreme outliers
    """
    def __init__(self):
        pass
    
    def apply(self):
        pass

class Hilbert:
    """
    apply hilbert transform to get envolope of signal
    """
    def __init__(self, Fz):
        self.__Fz_ = Fz;

    def apply(self, signal):
        analytic_signal = hilbert(signal);
        envelope =  self.amplitude_envelope(analytic_signal)
        freq     = self.instantaneous_frequency(analytic_signal)
        return (envelope, freq)
    def amplitude_envelope(self, analytic_signal):
        envelope = np.abs(analytic_signal);
        return envelope;

    def instantaneous_frequency(self, analytic_signal):
        phase = np.unwrap(np.angle(analytic_signal));
        freq = np.diff(phase) / (2.0*np.pi) * self.__Fz_;
        return freq;
    
class Model:
    """
    deep learning model to detect location of peaks
    """
    def __init__(self):
        pass

    
    
