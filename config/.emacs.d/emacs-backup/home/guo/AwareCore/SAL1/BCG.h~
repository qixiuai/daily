#ifndef _BCG
#define _BCG

#include <exception>
#include <memory>
#include <vector>
#include <string>
#include <iostream>
#include <stdexcept>
#include <thread>
#include <chrono>
#include <cmath>
#include <numeric>
#include <algorithm>
#include <list>
#include <boost/circular_buffer.hpp>

//namespace AwareTech {
  template <class T>
  using Buffer = boost::circular_buffer<T>;
  
  struct QualityResult {
    bool is_on_bed;
    int level; // -2 very bad, -1 bad, 0 soso, 1 good, 2 very good;
  };
 
  class Quality {
    template <class T>
    using Buffer        = boost::circular_buffer<T>;
    using SignalValue   = int;
    using EntropyValue  = float;
    using QualityValue  = float;
    using EntropyBuffer = Buffer<EntropyValue>;
    using SignalBuffer  = Buffer<SignalValue>;
    
  private:
    SignalValue __max_ = 4096;
    //  const SignalValue __min_ = 0;
    int     __num_bucket_;
    int     __window_size_;
    int     __total_counts_;
    
    SignalBuffer  __signal_;
    EntropyBuffer __H_;
    std::vector<float> __bucket_counts_;

    EntropyValue __realtimeEntropyInit(SignalValue __val);  
    EntropyValue __realtimeEntropy(SignalValue __in_val, SignalValue __out_val);

    float __calcEntropyFromBucket();
    int __determineQualityLevel(float __stddev);
    
  public:
    Quality(){};
    explicit Quality(int __num_bucket, int __window_size);
    void reset();
    QualityResult realTimeQuality(SignalValue __in_val);
  };


  struct Config {
    int Fz;
    int window_size;
    int max_window_size;
    int min_window_size;
    float u0 = 70;
    int k0 = 5;
    int n0 = 60;
  };

  struct DisMaxResult {
    int rate;
    int offset;
  };

 
  class DisMax {
  public:
    using Signal = Buffer<double>;
    using MovAvg = Buffer<double>;
    using MovDev = Buffer<double>;
    using MovMax = Buffer<double>;
    using MovDur = Buffer<double>;
  
    using WindowSizeType = uint32_t;
    using PeakOffset     = int32_t;
    using PeakIndex      = uint64_t;
    using PeakPeriod     = int32_t;
    using SampleIndex    = uint64_t;
    using PeakFreq       = float;
    using PeakNumber     = uint32_t;
    using PotentialPeaks = std::vector<PeakIndex>;
    using PotentialDurs  = std::vector<double>;
    using Peaks          = std::list<PeakIndex>;
    
    DisMax()  = default;
    ~DisMax() = default;
    explicit DisMax(const Config& config);
    DisMaxResult run(int x); // int is Signal Data
    void reset();
  
  private:
    Config __config_;

    Signal __signal_;
    MovAvg __movavg_;
    MovDev __movdev_;
    MovMax __movmax_;
    MovDur __dur_;
  
    PeakIndex   __last_peak_;
    PeakPeriod  __last_period_;
    SampleIndex __sample_index_;
  
    PeakFreq       __u_;
    PeakNumber     __n_;
    PotentialDurs  __potential_durs_;
    PotentialPeaks __potential_peaks_;

    Peaks __peaks_per_mimute_;
  
    double __movdev(const Signal& __signal,
		    const MovAvg& __movavg) const {
      auto __sz = __signal.size();
      double __dev = 0;
      for (int __i = 0; __i < __sz; __i++) {
	__dev += std::abs(__signal[__i] - __movavg[__i]);
      }
      __dev /= __sz;
      return __dev;
    }
  
    template <class T> double __mean(const Buffer<T>& __buf) const {
      double __sum = std::accumulate(__buf.begin(), __buf.end(), 0);
      return __sum / __buf.size();
    }
    int __getRatePerMinute(int __sample_index);
    
    void __adjustWindowSize(const PeakPeriod& __current_period) ;

  };
  
struct BCGResult {
  int   is_on_bed;    
  int   quality_level;
  int   heart_rate;
  int   heart_offset;
  int   respiratory_rate;
  int   respiratory_offset;
  BCGResult();
  friend std::ostream& operator<<(std::ostream& os, const BCGResult& result);
};

class BCGFramework {
  private:    
    float __Fz_;

    Quality __quality_;
    DisMax __heart_dismax_;
    DisMax __respiratory_dismax_;
    
    BCGResult __result_;
    
    void __runQuality(int value);
    void __runHeartDisMax(int val);
    void __runRespiratoryDisMax(int val);
  public:
    BCGFramework(int Fz);
    BCGResult run(int value, bool is_reset=false);
  }; 

/*
  std::ostream& operator<<(std::ostream& os, const BCGResult& result) {
    auto on_pillow = result.is_on_bed ? "true" : "false";
    os <<"-----------------------------------------------------------\n";
    os << "SignalQuality:       " << result.quality_level        << '\n' \
       << "IsOnBed:             " << on_pillow                   << '\n' \
       << "HeartRate:           " << result.heart_rate           << '\n' \
       << "HeartPosition:       " << result.heart_offset         << '\n' \
       << "RespiratoryRate:     " << result.respiratory_rate     << '\n' \
       << "RespiratoryPosition: " << result.respiratory_offset   << '\n';
    os <<"-----------------------------------------------------------\n";
    return os;
  }  
*/
  //} // end namespace AwareTech
  



#endif


