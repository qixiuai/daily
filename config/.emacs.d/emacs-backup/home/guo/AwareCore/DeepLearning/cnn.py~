import torch
import torch.nn as nn
import torch.nn.functional as F
from scipy.io import loadmat
import numpy as np

def load_data(data_dir="data/"):
    X = loadmat(data_dir+"X.mat")
    Y = loadmat(data_dir+"Y.mat")
    X, Y = X["X"], Y["Y"]
    nrow, ncol = X.shape
    X = X.reshape(nrow)
    nrow, ncol = Y.shape
    Y = Y.reshape(nrow)
    return (X, Y)

def resample_data(X, Y):
    numelm   = X.shape[0];
    truncate = np.int(numelm / 1000) * 1000;
    X = X[:truncate];
    Y = Y[:truncate];
    X = X.reshape(-1, 1, 1000);
    Y = Y.reshape(-1, 1000);
    return (X, Y);

class Net(nn.Module):
    """
    Peak Locator Model
    """
    def __init__(self):
        super(Net, self).__init__()
        self.conv1 = nn.Conv1d(1,  6, 5);
        self.conv2 = nn.Conv1d(6, 16, 5);
        self.conv3 = nn.Conv1d(16, 1, 5);

    def forward(self, x):
        self.conv1(x);
        x = F.max_pool1d(F.relu(self.conv1(x)), 2);
        x = F.max_pool1d(F.relu(self.conv2(x)), 2);
        x = F.max_pool1d(F.relu(self.conv3(x)), 2);
        return x;

X, Y = load_data();
X, Y = resample_data(X, Y);
X = torch.from_numpy(X);
print(X.dtypetorch.float64
Net(
  (conv1): Conv1d(1, 6, kernel_size=(5,), stride=(1,))
  (conv2): Conv1d(6, 16, kernel_size=(5,), stride=(1,))
  (conv3): Conv1d(16, 1, kernel_size=(5,), stride=(1,))
)
Traceback (most recent call last):
  File "cnn.py", line 51, in <module>
    output = model(X)
  File "/home/guo/anaconda3/lib/python3.6/site-packages/torch/nn/modules/module.py", line 491, in __call__
    result = self.forward(*input, **kwargs)
  File "cnn.py", line 37, in forward
    self.conv1(x);
  File "/home/guo/anaconda3/lib/python3.6/site-packages/torch/nn/modules/module.py", line 491, in __call__
    result = self.forward(*input, **kwargs)
  File "/home/guo/anaconda3/lib/python3.6/site-packages/torch/nn/modules/conv.py", line 176, in forward
    self.padding, self.dilation, self.groups)
RuntimeError: Expected object of type torch.DoubleTensor but found type torch.FloatTensor for argument #2 'weight'
)
Y = torch.from_numpy(Y);
model = Net();
print(model)

output = model(X)
criterion = nn.CrossEntropyLoss()
loss = criterion(output, Y)
print(loss)



