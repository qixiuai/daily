
#ifndef _DISMAX_
#define _DISMAX_

#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <cmath>
#include <numeric>
#include <chrono>
#include <thread>
#include <list>
#include <boost/circular_buffer.hpp>
//#include <glog/logging.h>
#include <__debug>

namespace AwareTech {

template <class T>
using Buffer = boost::circular_buffer<T>;
using std::cout;
using std::endl;

 struct Config {
   int Fz;
   int window_size;
   int max_window_size;
   int min_window_size;
   int u0 = 70;
   int k0 = 5;
   int n0;
 };

 struct DisMaxResult {
   int rate;
   int offset;
 };

 
class DisMax {
public:
  using Signal = Buffer<double>;
  using MovAvg = Buffer<double>;
  using MovDev = Buffer<double>;
  using MovMax = Buffer<double>;
  using MovDur = Buffer<double>;
  
  using WindowSizeType = uint32_t;
  using PeakOffset     = int32_t;
  using PeakIndex      = uint64_t;
  using PeakPeriod     = int32_t;
  using SampleIndex    = uint64_t;
  using PeakFreq       = float;
  using PeakNumber     = uint32_t;
  using PotentialPeaks = std::vector<PeakIndex>;
  using PotentialDurs  = std::vector<double>;
  using Peaks          = std::list<PeakIndex>;
  
  
  DisMax()  = default;
  ~DisMax() = default;
  explicit DisMax(const Config& config);
  DisMaxResult run(int x); // int is Signal Data
  void reset();
  
private:
  Config __config_;

  Signal __signal_;
  MovAvg __movavg_;
  MovDev __movdev_;
  MovMax __movmax_;
  MovDur __dur_;
  
  PeakIndex   __last_peak_;
  PeakPeriod  __last_period_;
  SampleIndex __sample_index_;
  
  PeakFreq       __u_;
  PeakNumber     __n_;
  PotentialDurs  __potential_durs_;
  PotentialPeaks __potential_peaks_;

  Peaks __peaks_per_mimute_;
  
  double __movdev(const Signal& __signal,
		  const MovAvg& __movavg) const {
    auto __sz = __signal.size();
    double __dev = 0;
    for (int __i = 0; __i < __sz; __i++) {
      __dev += std::abs(__signal[__i] - __movavg[__i]);
    }
    __dev /= __sz;
    return __dev;
  }
  
  template <class T> double __mean(const Buffer<T>& __buf) const {
    double __sum = std::accumulate(__buf.begin(), __buf.end(), 0);
    return __sum / __buf.size();
  }
  int __getRatePerMinute(int __sample_index);
    
  void __adjustWindowSize(const PeakPeriod& __current_period) ;

};
 
} // end namespace AwareTech

#endif
