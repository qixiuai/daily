#ifndef BCG_DISMAX_BUFFER
#define BCG_DISMAX_BUFFER

#include <memory>
#include <stdexcept>

namespace DisMax {
  template <class T>
    class Buffer {
  private:
    int capacity;

    void adjustBufferShorter(int window_size) {
	this->capacity = window_size;
	this->size     = window_size;
	if (this->end == window_size)
	  return;
	if (this->end < window_size) {
	  for (int i = 0; i < window_size; i++)
	    data.get()[window_size-1-i] = data.get()[end-1-i];
	  return;
	}
	for (int i = 0; i < window_size; i++) {
	  data.get()[i] = data.get()[end-window_size+i];
	}
    }
    
    void adjustBufferLonger(int window_size) {
	if (this->end == window_size)
	  return;
	auto ldata = std::shared_ptr<T>(new T[window_size], \
					std::default_delete<T[]>());
	T m = 0;
	T val;
	for (int i = 0; i < this->size; i++) {
	  val =  ldata.get()[this->end-1-i];
	  ldata.get()[window_size-1-i] = val;
	  m += val;
	}
	m /= this->size;
	for (int i = 0; i< window_size - this->size; i++) {
	  ldata.get()[i] = m;
	}
	this->data     = ldata;
	this->size     = window_size;
	this->end      = window_size;
      	this->capacity = window_size;
    }
    
  public:
    int size;
    int end;
    std::shared_ptr<T> data; // Further make it private
    
    Buffer() {
      this->capacity = 0;
      this->size     = 0;
      this->end      = 0;
    }
    Buffer(int window_size) {
      this->end      = 0;
      this->size     = 0;
      this->capacity = window_size;
      this->data     = std::shared_ptr<T>(new T[window_size], \
				      std::default_delete<T[]>());
    }
    
    bool isFull() const {
      return this->size == this->capacity;
    }

    void push(T value) {
      if (this->size < this->capacity)
	this->size += 1;
      if (this->end == this->capacity)
	this->end = 0;
      this->data.get()[this->end] = value;
      this->end += 1;
    }
    
    T operator[](int index) const {
      if (index < 0)
	throw std::underflow_error("index of Buffer cann't be negative!");
      if (index > this->capacity)
	throw std::overflow_error("Index exceeds bound of Buffer!");
      
      auto real_index = (this->end + index) % this->capacity;
      return this->data.get()[real_index];
    }

    void adjustBuffer(int window_size) {
      // better allocate a bigger buffer. when adjustbuffer, just ajust size
      if (this->size < this->capacity)
	throw std::runtime_error("Buffer is not full, can't adjust size!");
      if (this->size == window_size)
	return;
      if (this->size > window_size)
	return adjustBufferShorter(window_size);
      return adjustBufferLonger(window_size);
    }
    
    void reset() {
      this->size = 0;
      this->end  = 0;
    }    

    T getMaximum() const {
      T maximum = 0, val;
      for (int i = 0; i < this->size; i++) {
	val = (*this)[i];
	if (val > maximum)
	  maximum = val;
      }
      return maximum;
    }

    double getMean() const {
      double m = 0;
      for (int i = 0; i < this->size; i++) {
	m += (*this)[i];
      }
      m /= this->size;
      return m;
    }      
  };
    
}

#endif
